博学之, 审问之, 慎思之, 明辨之, 笃行之;
零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;

视频地址: (https://ke.qq.com/course/5855339#term_id=106263629)
         (https://www.bilibili.com/video/BV1o8411x7K3?spm_id_from=333.788.videopod.episodes&vd_source=6122dea75af0b44c85ff18d196f1b32d&p=134)

零.第一个Cpp程序 (helloworld)

    命令行gcc运行:
        指定输出:
            gcc -lstdc++ main.cpp -o test
                生成 test
            ./test
                输出： Hello World！
        不指定输出:
            gcc -lstdc++ main.cpp
                生成 a.out
            ./a.out
                输出： Hello World！
    CLion集成环境：
        Tools ==> CMake ==> Unload CMake Project
        这样会在 cpp 文件中自动提示 Create CMakeLists.txt
        点击它将自动在根目录生成 CMakeLists.txt 配置文件
    
    XCode集成环境：
        Create a new Xcode Project
        macos ==> Command Line Tool
        在项目构建窗口中自行配置项目信息，注意Language 选择 C++ 即可。
    
    后续都将用XCode集成环境进行学习

壹.命名&注释&变量&常量 (001designate&variable&Constant)

    数据是信息的载体,C程序大多时的目的就是为了处理数据.
    数据的分类:
        数字,字符,字符串三种类型:
        字符是单引号,字符串是双引号.
    
    输出数据:
        std::cout               输出各种类型的数据
        <<                      输出操作符,可以拼接多个数据项
        std::endl               也可以用于换行
        using namespace std;    指定缺省的命名空间
    
    注释:
        单行注释: //
        单行注释: /**/
        多行注释可以注释掉单行注释,单行注释也可以注释掉多行注释(牛逼,已经不认识释这个字了)
    
    变量:
        C++中常用的数据类型:
            整数(int)
            浮点数(float,double)
            字符(char)
            字符串(string)
            布尔(bool)
        注意: C++ 中ture输出是用1表示,false用0表示
    
    常量:
        宏常量:
            一般在main函数外面声明,用大写命名,注意宏常量结尾不需要分号
        const修饰的常量:
            在程序的任何地方都可以声明.
        常量值的特点即不能被修改.
    
    标识符的命名:
        C++规定给标识符命名时(变量,常量,函数,结构体,类等),必须遵守以下规则:
            字母,数字,下划线命名.
            命名首位不能是数字.
            命名大小写区分.
            不能以关键字进行命名.
            下划线和大写字母打头的名称,被保留个编译器和其使用的资源使用,可以这么用但是不推荐.因为C++会扩展,过几年就会有新的标准,下划线命名的名称现在不会和新标准冲突,
                并不表示以后也是合法的.所以最好别这么用.
    
    输入数据:
        程序输入数据的方式有多种:
            从控制台命令行的界面中输入.
            从文件中读取.
            从数据库中读取.
            从网络中读取.
        语法:
            std::cin                输入各种类型的数据
            >>                      输入操作符,可以拼接多个数据项
        注意:
            布尔型变量输入时只能填0和非0,非0将转换为1.
            如果命令行中输入的数据和程序中变量的数据类型不匹配.会导致行为的不确定性.

贰.算术运算 (002arithmetic)

    算术运算:
        整数如果除0,程序将异常退出.
        浮点数如果除0,将得到Inf(infinite)
        整数与浮点数进行除法运算时,得到的结果是浮点数
        进行除法运算时,在整数前面加(float)或(double)可以将整数转换为浮点数,这是强制类型转换的结果
        求余运算只能用于整数,且分母不能为0.
    
    自增和自减:
        ++a: 先把变量值加1, 然后再执行表达式.
        a++: 先执行表达式, 再把变量值加1.
        --a: 先把变量值减1, 然后再执行表达式.
        a--: 先执行表达式, 再把变量减1.
    
    赋值运算符:
        =
        +=
        -=
        *=
        /=
        %=
        
    C++11初始化赋值:
        C++ 标准:
            int h = 10;
            int j = (10);
            int k (10);
        
        C++11 标准:
            int h1 = 10;
            int j1 = {10};
            int k1 {10};
    
        注意: 在Linux平台下, 编译需要加 -std=c++11 参数, 否则会报错.

    关系运算:
        用于比较两个表达式的值, 运算的结果为1和0, 即 1-true 和 0-false.
        
        ==
        !=
        <
        <=
        >
        >=
        
       注意:
            std::cout输出关系运算表达式时, 关系表达式要加括号, 否则会报错.
    
    逻辑运算:
        &&
        ||
        !

    逗号运算:
        赋值运算符的结合律(顺序)是从右到左,如:(a = b = 10).
        算术运算的组合方式是从左到右,如:(a * b / c).
        括号优先级除数组下标外是最高的, 可以改变全部运算符的优先级.

叁.条件分支语句(003conditionStatement)

    经典 if else 语句:
        注意事项:
            if和else语句如果只是执行一行语句,那么可以不写花括号,如果是多行语句就不需要写花括号.
    
    三目运算:
        c = (a > b) ? a : b
        
    switch语句:
        注意每个case条件中不要漏掉 break, 如果使用 return 语句, 后面必须跟个值一般return 0即可.

肆.循环语句(004circulateStatement)

    while:
        while(express){
            statement;
        }
    
    循环的跳转:
        break
            跳出(终止)当前循环语句
        continue
            回到当前循环语句的首部
    for:
        for(int i = 0; i < 10; i++) {
            cout << "当前的值是: " << i << endl;
        }
    嵌套循环:
        99乘法表实现.
    do while:
        int a = 10;
        do{
            cout << a++ << endl;
        }while(a < 20);
        和while的区别: 无论条件是否成立都会首先执行一次.
    goto:
        goto语句也被称为无条件转移语句.
        语法:
            cout << "第1个程序员的编号" << endl;
            goto bbb;
            cout << "第2个程序员的编号" << endl;
            cout << "第3个程序员的编号" << endl;
            cout << "第4个程序员的编号" << endl;
            bbb: cout << "第5个程序员的编号" << endl;
        输出结果:
            第1个程序员的编号
            第5个程序员的编号
        建议:
            在实际开发中,goto语句很容易造成程序流程的混乱,对维护工作带来很大压力,所以几乎看到goto语句的应用,也不建议使用.

伍.函数基础(005fundamentalsOfFunc)

    函数声明:
        int maxNum(int a, int b);
    函数定义:
        int maxNum(int a, int b) {
            return a > b ? a : b;
        }
        注意:
            函数的定义和声明可以书写在一起, 如果在一起, 一般在main函数的上面, 如果分开, 一般在main函数上面声明, 在main函数下面定义
            一般开发中都是将它们分开书写, 声明是声明, 定义是定义.
            在同一个程序中, 函数只需要声明和定义一次, 也可以多次声明, 但只能定义一次;
            函数的声明必须和定义的一致(返回值类型,函数名,参数列表), 否则程序将认定他们不是同一个函数.
    函数调用:
        cout << "man(5,8) = " << maxNum(5,8) << endl;
        注意:
            如果函数的重点是实现功能, 不关心返回值, 返回值的数据类型为void, return后面直接分号结束即可.
            声明函数的代码必须放在调用之前, 定义函数的代码可以放在调用之后.
            main函数不能被调用
    变量的作用域:
        注意:
            变量分全局和局部两种, 在全部函数外部定义的是全局变量.
            在头文件中定义的是全局变量.
            在函数和语句块内部定义的是局部变量.
            函数参数就是该函数的一种局部变量.
            函数内部用static修饰的是静态局部变量,简称静态变量.
                静态变量拥有和程序相同的生命周期,并且只会被初始化一次.
                当程序想要使用全局变量时,可以根据场景考虑优先使用静态变量.
                如果在代码块内部的局部变量和全局变量重名了, 可以通过 :: 来指定使用全局变量.
            for循环初始化语句中定义的变量只作用于for循环的语句块.
    函数参数传递:
        实参:
        形参:
    函数分文件编写:
        函数分文件编写:
            头文件(*.h | *.hpp)
                需要包含的头文件, 指定命名空间, 声明全局变量, 函数的声明, 数据结构和类的声明等...
            源文件(*.c | *.cpp)
                函数的定义, 类的定义.
            主程序(main函数)
                程序的核心流程, 需要用 #include "头文件名" 把头文件包含进来.
        注意:
            #include "tools.h"
                包含自定义的头文件使用双引号
            #include <iostream>
                包含系统的头文件使用尖括号
        编译:
            mac是集成开发环境,不需要写入编译指令.
            linux系统下,把全部的源文件,一起编译,如: gcc -o main main.cpp tools.cpp funcs.cpp
    递归函数:
        int recursion(int x){
            if (x == 0) return 0;
            return x + recursion(x-1);
        };

陆.C++数据类型(006dataType)

    C++四种基本数据类型:
        整数(int)
        浮点数(float/double)
        字符(char)
        布尔(bool)
    
    sizeof
        sizeof运算符是用于求数据类型或变量占用的内存空间
        用于数据类型:
            sizeof(数据类型)
        用于变量:
            sizeof(变量名)
            sizeof 变量名
        注意:
            在32位和64位操作系统中,同一数据类型占用的内存空间可能不一样.
            字符串(string)不是c++的基本数据类型,是c++中的一个类,用sizeof求它占用内存的大小没有意义.
    
    整型的基本概念
        int 是 integer 的简写
        在声明整型变量时,可以在int之前加 signed, unsigned, short, long四种修饰符.
            signed: 有符号的,可以表示正数和负数
            unsigned: 无符号的,只能表示正数
            short: 短的,取值范围小,占用内存少
            long: 长的,取值范围大,占用内存多
        一共四个修饰符,前面两个和后面两个组合,把整数分成了六种类型:
            简写                  全写                      含义                字节占用
            short               (signed short int)        短的                byte 2        
            unsigned short      (unsigned short int)      无符号短的            byte 2          
            int                 (signed int)              适中的               byte 4
            unsigned int        (unsigned int)            无符号适中的          byte 4
            long                (signed long int)         长的                 byte 8
            unsigned long       (unsigned long int)       无符号适中的          byte 8
        根据sizeof的内存大小推断它的取值范围:
            一个位的取值是: 0 1                ==>     2¹ - 1 = 1
            两个位的取值是: 00 01 10 11        ==>     2² - 1 = 3
            三个位的取值是: 000 001 ... 111    ==>     2³ - 1 = 7
        公式:
            一个字节有八个位,表示的数据的取值范围是 2⁸-1, 取值范围是255
            如果占用的内存是两个字节,无符号型的取值范围是 2⁸*2⁸-1
            如果占用的内存是四个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸-1
            如果占用的内存是八个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸-1
            如果是有符号,取值范围减半,因为符号占一个位
        注意:
            long在windows下的字节长度和int一样都是4字节, 在mac和linux下是8字节
                所以根据上面的公式推算,long在不同操作系统下的取值范围是不同的.
            整数的取值范围与计算机操作系统和C++语言编译器有关,没有固定值,可以根据它占用的内存大小来推断它的取值范围
            如果超出取值范围,编译不会报错并且程序能够运行,但是结果是错误的,数据会被截断, 如:
                unsigned short int usi1 = 65535 + 1;        ==>         0
                unsigned short int usi2 = 65535 + 2;        ==>         1
                unsigned short int usi3 = 65535 + 3;        ==>         2
                unsigned short int usi100 = 65535 + 100;    ==>         99
            在实际开发中,为了防止超出取值范围,应该保证有足够的空间.
            C++把整型细分为六种数据类型,目的是为了节省内存空间,但是不能省的就不要省,避免出问题.
        
    整数的书写
        整数默认是十进制,一个表示十进制的数字不需要任何特殊的格式
            但是二进制,八进制和十六进制的数字就不一样,为了和十进制的数字分开,在数字前面加了特定的字符前缀.
        十进制:
            int a = 100;                    ==>         100
        二进制(0b|0B):
            二进制由01两个数字组成,书写时必须以0b或0B(不区分大小写)开头.
                int aa = 0b101;             ==>         5
                int bb = -0b110010;         ==>         -50
                int cc = 0B100001;          ==>         33
        八进制(0):
            八进制由 0~7 八个数字组成, 书写时必须以0开头
            在Linux系统中,设备的权限都是用八进制来表示的.
                int aaa = 015;              ==>         13
                int bbb = -0101;            ==>         -65
                int ccc = 0177777;          ==>         65535
        十六进制(0x|0X):
            十六进制由数字 0~9,字母 A~F或a~f(不区分大小写)组成,书写时必须以0x或0X(不区分大小写)开头.
            在C++中,内存地址缺省用十六进制表示.
                int aaaa = 0x2a;            ==>         42
                int bbbb = -0xa0;           ==>         -160
                int cccc = 0xffff;          ==>         65535
        注意:
            在C++中,不要在十进制的前面加0,会被编译器当成八进制.
            还有不要随便删掉别人代码中整数前面的0,C++程序中的任何一个0都不会是多余的.
    
    long-long类型
        在VS中, long是4字节, 32位, 取值范围:-2147483648~2147483647
        在Liunx中, long是8字节, 64位, 取值范围:-9223372036854775808~9223372036854775807
        C++11增加了 long long 类型的整数, 至少64位, 且至少与long一样长.
        在VS中，long long是8字节，64位, 取值范围: -9223372036854775808~9223372036854775807
        在Linux中，long和long long类型都是8字节，64位。
        
    浮点型
        浮点数也成为实数型
        C++浮点型分三种, float(单精度), double(双精度), long double(扩展精度)
        三者的区别是表示有效数字的范围不同:
            float           byte 4          7位有效数字
            double          byte 8          15~16位有效数字
            long double     不小于double     不低于double
        注意：
            在VS和Linux中，long double占用的内存空间分别是8和16字节。
            有效数字包括了小数点前面和后面的数字。
            C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数。
            在实际开发中，用整数代替浮点数，整数的运算更快，精度更高。
            在VS中如果书写一个小数, 默认会将该小数当作double类型, 所以如果要声明为float 需要在小数后面加上f表示float.
                如: float x = 123.456789f;
                
    字符型的基本概念
        字符甚至可以理解为和整数是同一种东西.
        字符型(char)占用的内存空间是1字节, 书写用单引号包含.
        在内存中, 不用存放字符本身, 而是存放它对应的编码, 即ASCII码.
        ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）
        是现今最通用的单字节编码方案，包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。
            'X'     -> 88   01011000
            'a'     -> 97   01100001
            '3'     -> 51   00110011
        概念:
            a）字符的本质是整数，取值范围是0～127。
            b）在书写的时候可以用单引号包含，也可以用整数。
            c）如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。
            d）显示的时候，把整数解释为对应的符号，也可以直接显示整数。
            d）可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。
            e）C++为什么没有提供1字节的整型？
    
    转义字符
        常用的转义字符:
            0           \0                  NULL,空,给字符型变量赋值可以直接书写0
            10          \n                  换行(LF),将当前位置移到下一行开头
            13          \r                  回车(CR),将当前位置移到本行开头
            9           \t                  水平制表(HT),跳到下一个TAB位置
            11          \v                  垂直制表(VT),跳到下一个TAB位置
            92          \\                  斜线
            
    Cpp11原始字面量
        原始字面量可以直接表示字符串的实际含义, 不需要转移和连接.
        如:
    
    字符串型
        C++风格字符串:   string 变量名 = "字符串内容"
        C风格字符串:     char 变量名[] = "字符串内容"
        C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。
        Cpp风格字符串的常用操作: 赋值, 拼接.
        注意:
            如果字符串的内容都是常量,就不能进行拼接,否则会报错.
                如: string str = "111"+"222"+"333";
            如果内容很长,cpp中还可以分为多行书写.
                如: string str = "111""222""333";
    
    布尔型
        在C和C++中，关系运算和逻辑运算的结果有两种：真和假。
        C语言用0表示假，非0表示真。
        为了提高代码的可读性，C++新增了bool 类型，占用1字节的内存，用true表示真，false表示假。
        bool类型本质上是1字节的整数（unsigned char），取值只有1和0。
        在程序中，书写的时候可以用true和false，编译器把它们解释为1和0。
        如果对bool型变量赋非0的值，将转换成1。
        用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。
    
    数据类型转换
        计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。
        在实际开发中，不同类型的数据进行混合运算是基本需求。
        自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。
            不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。
            整型从低到高：
                char -> short -> int -> long -> long long
            浮点型从低到高：
                float -> double -> long double
            自动类型转换的规则如下：
                如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动向较高类型转换。
                当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。
                赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
                赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。

        强制类型转换：有些类型的转换需要程序员显式指定。
            为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。
            强制类型转换的语法：(目标类型)表达式
            注意：
                如果使用强制转换，表示程序员已有明确的目的。
                如果转换的行为不符合理，后果由程序员承担。
                如果采用了强制类型转换，编译的告警信息将不再出现。
                类型转换运算符的优先级比较高，如果没把握就加括号。
        
    数据类型别名
        创建数据类型的别名有两个目的：
            为名称复杂的类型创建别名，方便书写和记忆。
            创建与平台无关的数据类型，提高程序的兼容性。
        语法：
            typedef 原数据类型名 别名;
        C++11还可以用using关键字创建数据类型的别名。
            using 别名=原数据类型名;

柒.指针和内存(007PointersAndMemory)

    指针的基本概念
        变量是内存变量的简称，在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。
        C++用运算符&获取变量在内存中的起始地址。
        语法：&变量名
        注意:
            cout输出某些类型时会有bug,显示地址时,会当作字符串显示.
                解决:将地址强转为 void*
                    (void*)&a
                解决:将地址强转为 int
                    (long long)&a
                    因为整数只有是个字节,容纳不下地址,所以要用long long.
            指针默认是用十六进制表示的,不过为了方便我们都用 long long 转为十进制.
        指针变量
            指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。
            语法：数据类型 *变量名;
            数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。
            星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。
        对指针赋值
            不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
            指针也是有类型的,所以声明指针时需要指定数据类型,不同的类型的指针是有区别的.
            我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；
            用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址等...
            注意
                对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
                    如: int *pa = &a;
                    可以解释为: 让指针pa 指向变量a, 指针的基类型是 int.
                如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。
                    如: int *pa = (int*)&b
        指针占用的内存
            指针也是变量，是变量就要占用内存空间。
            在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节, 32位系统是4字节.
            在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，int*是整型指针类型，int*可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把int*当成一种数据类型就是了。
        总结:
            和 golang 一样
            &用于取变量的内存地址, 称为引用运算符 或 地址运算符
            *用于声明指针 和 根据地址取值, 称为间接值 或 解引用运算符
    
    使用指针
        声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。
        指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）
        *运算符被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值.
        *也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
        对变量赋初始值是一个好习惯, 一般在定义完之后就应该要赋初始值.
    
    指针用于函数的参数
        如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。
        值传递：
            函数的形参是普通变量,那么在函数中操作形参不会对实参产生影响.因为值传递是对实参的拷贝.
        地址传递的意义：
            可以在函数中修改实参的值。
                因为cpp中的函数只能有一个返回值, 所以在实际开发中对修改函数中实参值的应用场景非常多
                可以通过函数参数的地址传递对实参进行修改,从而达到类似多个返回值的功能,如(func2)
            减少内存拷贝，提升性能。
                解释:
                    如果用指针变量:
                        int* no = &a2;              int*        内存占用    8字节
                        string* msg = &messages;    string*     内存占用    8字节
                    如果用普通变量:
                        int no = a2;                int         内存占用    4字节
                        string msg = messages;      string      内存占用    40字节
                    so,明白了吧, 普通变量的内存开销是44字节, 而指针的内存开销占用只有16字节
                    即减少了内存的开销或占用, 以提升性能.
    
    用const修饰指针
        常量指针(用的比较多)
            语法：const 数据类型 *变量名;
            不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。
            注意：
                指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
                一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
                如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
                如果形参的值不需要改变，建议加上const修饰，程序可读性更好。
        指针常量
            语法：数据类型* const 变量名;
            指向的变量（对象）不可改变。
            注意：
                在定义的同时必须初始化，否则没有意义。
                可以通过解引用的方法修改内存地址中的值。
                C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。
        常指针常量
            语法：const 数据类型 * const 变量名;
            指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值。
        总结:
            常量指针：指针指向可以改，指针指向的值不可以更改。
            指针常量：指针指向不可以改，指针指向的值可以更改。
            常指针常量：指针指向不可以改，指针指向的值不可以更改。
    
    void关键字
        在C++中，void表示为无类型，主要有三个用途：
            函数的返回值用void，表示函数没有返回值。
                void func(int a,int b)
                {
                    // 函数体代码。
                    return;
                }
            函数的参数填void，表示函数不需要参数（或者让参数列表空着）。
                int func(void)
                {
                    // 函数体代码。
                    return 0;
                }
            函数的形参用void*，表示接受任意数据类型的指针。
                不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。
                不能对void *指针直接解引用（需要转换成其它类型的指针）。
                把其它类型的指针赋值给void*指针不需要转换。
                把void *指针赋值给把其它类型的指针需要转换。
    
    Cpp内存模型
        在C++中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段。
            栈：存储局部变量、函数参数和返回值。
            堆：存储动态开辟内存的变量。
            数据段：存储全局变量和静态变量。
            代码段：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。
        栈和堆的主要区别：
            1）管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。
            2）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。
            3）分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。
            4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。
            5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。
            6）增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。

    动态分配内存new和delete
        使用堆区的内存有四个步骤：
            1）声明一个指针；
            2）用new运算符向系统申请一块内存，让指针指向这块内存；
            3）通过对指针解引用的方法，像使用变量一样使用这块内存；
            4）如果这块内存不用了，用delete运算符释放它。
        申请内存的语法：new 数据类型(初始值);
            如果申请成功，返回一个地址；如果申请失败，返回一个空地址,如果是C++11标准语法还可以: new 数据类型{初始值}.
        释放内存的语法：delete 地址;
            释放内存不会失败。
        注意：
            动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
            如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存(重要)。
            动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
            就算指针的作用域已失效，所指向的内存也不会释放。
            用指针跟踪已分配的内存时，不能跟丢。
        
    二级指针
        指针是指针变量的简称，也是变量，是变量就有地址。
        指针用于存放普通变量的地址。
        二级指针用于存放指针变量的地址。
        声明二级指针的语法：数据类型** 指针名;
        使用指针有两个目的：
            传递地址；
            存放动态分配的内存的地址。
        在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。
        把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中修改指针的值.
        
    空指针
        在C和C++中，用0或NULL都可以表示空指针,声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。
        使用空指针的后果
            如果对空指针解引用，程序会崩溃。
            如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。
            在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。
        C++11的nullptr
            用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。
            NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。
            注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。
            
    野指针
        野指针就是指针指向的不是一个有效（合法）的地址。
        在程序中，如果访问野指针，可能会造成程序的崩溃。
        出现野指针的情况主要有三种：
            1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。
            2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。
            3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收),把指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针,会发生该情况.
        规避方法：
            1）指针在定义的时候，如果没地方指，就初始化为nullptr。
            2）动态分配的内存被释放后，将其置为nullptr。
            3）函数不要返回局部变量的地址。
            4) 使用智能指针
        注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。
        
    函数指针和回调函数
        函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。
        使用函数指针的三个步骤：
            a）声明函数指针；
                声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）
                假设函数的原型是：
                    int func1(int bh,string str);
                    int func2(int no,string message);
                    int func3(int id,string info);

                    bool func4(int id,string info);

                    bool func5(int id);
                则函数指针的声明是：
                    int  (*pfa)(int,string);

                    bool (*pfb)(int,string);

                    bool (*pfc)(int);
                pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。
            b）让函数指针指向函数的地址；
                函数名就是函数的地址。
                函数指针的赋值：函数指针名=函数名;
            c）通过函数指针调用函数。
                c语法:
                    (*函数指针名)(实参);
                cpp语法:
                    函数指针名(实参);

捌.数组(008Array)

    数组的基本概念
        数组是一组数据类型相同的变量，可以存放一组数据。
        创建数组
            语法：数据类型 数组名[数组长度];
            注意：
                数组长度必须是整数，可以是常量，也可以是变量和表达式。
                C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。
                经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        数组的使用
            可以通过下标访问数组中元素，数组下标从0开始。
            语法：数组名[数组下标]
            注意：
                数组下标也必须是整数，可以是常量，也可以是变量。
                合法的数组下标取值是：0~(数组长度-1)。
        数组占用内存的情况
            数组在内存中占用的空间是连续的。
            用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。
        数组的初始化
            声明的时候初始化：
                数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。
                数据类型 数组名[数组长度] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。
                如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
                C++11标准可以不写等于号。
        清空数组
            用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制数组
            用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    数组和指针
        指针的算术
            将一个整型变量加1后，其值将增加1。
            但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。
        数组的地址
            a）数组在内存中占用的空间是连续的。
            b）C++将数组名解释为数组第0个元素的地址。
            c）数组第0个元素的地址和数组首地址的取值是相同的。
            d）数组第n个元素的地址是：数组首地址+n
            e）C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
        数组的本质
            数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。
            C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。
        数组名不一定会被解释为地址
            在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数,所以数组名并不是的地址.
            可以修改指针的值，但数组名是常量，不可修改。
            
    数组的越界
        数组越界在windows下是会报错且终止程序运行的,但是在linux下所有越界的值都将赋为0.
        数组越界就是一种野指针, 所以开发时需要注意, 这种低级错误不要犯.
            int arr6[5] = {0,1,2,3,4};
            for (int i = 0; i < 8; i++) {
                arr6[i] = i + 100;
                cout << "arr6[ + " << i << "]的值是 = " << (long long)arr6[i] << endl;
            };
    
    数组用于函数的参数
        1）指针的数组表示
            在C++内部，用指针来处理数组。
            1) C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
            2) C++编译器把   地址[下标]  解释为  *(地址+下标)
        2）一维数组用于函数的参数
            一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。
            书写方法有两种： 
                void func(int* arr, int len);
                void func(int arr[], int len);
            注意：
                在函数中，可以用数组表示法，也可以用指针表示法。
                在函数中，不要对指针名用sizeof运算符,它不是数组名,
                    因为sizeof(数组名)得到的是数组的内存大小,如func();
                    而sizeof(指针名)得到的永远都是8字节,这就是为什么要把数组长度计算好再传进来的原因了
        
    用new动态创建数组
        普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。
        动态创建一维数组的语法：
            数据类型 *指针=new 数据类型[数组长度];
        释放一维数组的语法：
            delete [] 指针;
        注意：
            动态创建的数组没有数组名，不能用sizeof运算符。
            可以用数组表示法和指针表示法两种方式使用动态创建的数组。
            必须使用delete[]来释放动态数组的内存（不能只用delete）。
            不要用delete[]来释放不是new[]分配的内存。
            不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。
            对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。
            声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。
            如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。
            为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。
            
    数组排序
        qsort()函数用于对各种数据类型的数组进行排序。
        函数的原型：
            void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
            第一个参数：数组的起始地址(数组名)
            第二个参数：数组元素的个数（数组长度）。
            第三个参数：数组元素的大小（sizeof(数组的数据类型)）。
            第四个参数：回调函数的地址。
            回调函数决定了排序的顺序，声明如下：    
                int compar(const void *p1, const void *p2);
                1）如果函数的返回值< 0 ，那么p1所指向元素会被排在p2所指向元素的前面。
                2）如果函数的返回值==0，那么p1所指向元素与p2所指向元素的顺序不确定。
                3）如果函数的返回值> 0 ，那么p1所指向元素会被排在p2所指向元素的后面。
                
                void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
        qsort()函数的其它细节：
            形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。
            为什么需要第三个形参size_t size？
            size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）typedef unsigned long long size_t
            排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。
        
    数组查找
        折半查找也叫二分查找，只适用于已排序的数组（升序降序都可以）。
        
    C字符串
        cpp中的string使用方便,能自动扩展,无需担心内存问题,string是cpp的类,是对C中字符串的封装
        但在某些应用场景中,C字符串更方便和高效.
        C语言约定：如果字符型（char）数组的末尾包含了空字符\0（也就是0），那么该数组中的内容就是一个字符串。
        因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。
        声明一个最多存放20个英文字符或十个中文的字符串。
            char name[21];
        初始方法:
            char str2[11] = "hello";
            char str3[] = {"hello"};
            char str4[11] = {"hello"};
            char str5[11]{"hello"};
            char str6[11] = {0}
                把全部元素初始化为0,相当于清空字符串的意思
        清空字符串:
            memset(name,0,sizeof(name));
                把全部的元素置为0:
            str[0]=0;
                C约定了用0表示字符串的结束,那么第一个元素置为0,那么后面的任何值都没有意义了(不规范,有隐患,不推荐)
        字符串复制或赋值(strcpy)
            cpp字符串可以字节用等号赋值,但是c字符串不可以,要用strcpy函数实现赋值.
            char *strcpy(char* dest, const char* src);
            参数: 目标字符串,源字符串
            功 能: 将参数src字符串拷贝至参数dest所指的地址。
            返回值: 返回参数dest的字符串起始地址。
            复制完字符串后，会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串复制或赋值(strncpy)
            char * strncpy(char* dest,const char* src, const size_t n);
            功能：把src前n个字符的内容复制到dest中。
            返回值：dest字符串起始地址。
            如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。
            如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
            strncpy的坑点:
                strncpy(str8, "hello", 3);
                hello是五个字符,但是只有3个值,windows平台下会将其他值赋为垃圾值.
                解决这个问题就是在strncpy之前,用memset将字符数组清空:memset(str8, 0, sizeof(str8));
        获取字符串的长度(strlen)
            size_t  strlen( const char*  str);
            功能：计算字符串的有效长度，不包含0。
            返回值：返回字符串的字符数。
            strlen()函数计算的是字符串的实际长度，遇到0结束。
        字符串拼接(strcat)
            char *strcat(char* dest,const char* src);
            功能：将src字符串拼接到dest所指的字符串尾部。
            返回值：返回dest字符串起始地址。
            dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串拼接(strncat)
            char *strncat (char* dest,const char* src, const size_t n);
            功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。
            返回值：返回dest字符串的起始地址。
            如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。
            strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串比较strcmp()和strncmp()
            int strcmp(const char *str1, const char *str2 );
            功能：比较str1和str2的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            int strncmp(const char *str1,const char *str2 ,const size_t n);
            功能：比较str1和str2前n个字符的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。
            在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。
        查找字符strchr()和strrchr()
            const char *strchr(const char *s, int c);
            返回在字符串s中第一次出现c的位置，如果找不到，返回0。
            const char *strrchr(const char *s, int c);
            返回在字符串s中最后一次出现c的位置，如果找不到，返回0。
        查找字符串strstr()
            char *strstr(const char* str,const char* substr);
            功能：检索子串在字符串中首次出现的位置。
            返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。
        用于string的表达式
            可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。
        注意事项
            a）字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。
            b）结尾标志0后面的都是垃圾内容。
            c）字符串在每次使用前都要初始化，减少入坑的可能，是每次，不是第一次。
            d）不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。
            e）windoes平台中，默认C标准的字符串操作函数是不安全的，如果要使用C标准的字符串操作函数，要在源代码文件的最上面加 #define _CRT_SECURE_NO_WARNINGS，还可以通过 strcpy_s，strcat_s ... 等函数处理字符串函数操作的安全性问题,一般在linux平台下是不会有这些问题的,所以了解下即可.
    
    二维数组
        一维数组的数学概念是线性表，二维数组的数学概念是矩阵。
        创建二维数组
            声明二维数组的语法：数据类型 数组名[行数][列数];
            注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。
            C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        二维数组的使用
            可以通过行下标和列下标访问二维数组中元素，下标从0开始。
            二维数组中每个元素的特征和使用方法与单个变量完全相同。
            语法：数组名[行下标][列下标]
            注意：
            二维数组下标也必须是整数，可以是常量，也可以是变量。
            合法的行下标取值是：0~(行数-1)。
            合法的列下标取值是：0~(列数-1)。
        二维数组占用内存的情况
            用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。
            二维数组在内存中占用的空间是连续的。
            二维数组的数组名也被解释为起始地址,和一维数组是一样的,用一维数组的方法可以正常显示而为数组的内容
        二维数组的初始化
            声明的时候初始化：
            数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 },...... };
            数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4, ......};
            数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};
            数据类型 数组名[行数][列数] = { 0 };  // 把全部的元素初始化为0。
            数据类型 数组名[行数][列数] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
            C++11标准可以不写等于号。
        清空二维数组
            用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制二维数组
            用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组（没说多少维）。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    二维数组用于函数的参数
        指针复习:
            整型指针。
                int* p;
            一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。   
                int* p[3];
            函数p的返回值类型是整型的地址。
                int* p(); 
            p是函数指针，函数的返回值是整型。
                int (*p)(int ,int);
        概念:
            地址是地址,指针是指针,不要把地址说成指针,指针是一个容器,是用于存放地址的.
        行指针(数组指针):
            声明行指针的语法：数据类型 (*行指针名)[行的大小];  // 行的大小即数组长度。
            int (*p1)[3];  // p1是行指针，用于指向数组长度为3的int型数组。
            int (*p2)[5];  // p2行指针，用于指向数组长度为5的int型数组。
            double (*p3)[5];  // p3是行指针，用于指向数组长度为5的double型数组。
            一维数组名被解释为数组第0个元素的地址。
            对一维数组名取地址得到的是数组的地址，是行地址。
        二维数组名是行地址
            int bh[2][3] = { {11,12,13},{21,22,23} };
            bh是二维数组名，该数组有2两元素，每一个元素本身又是一个数组长度为3的整型数组。
            bh被解释为数组长度为3的整型数组类型的行地址。
            如果存放bh的值，要用数组长度为3的整型数组类型的行指针。
            int (*p)[3]=bh;

        把二维数组传递给函数
            如果要把bh传给函数，函数的声明如下：
            void func(int (*p)[3],int len);
            void func(int p[][3],int len);
        
    多维数组
        int bh[4][2][3];
        bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。
        bh被解释为2行3列的二维数组类型的二维地址。
        如果存放bh的值，要用2行3列的二维数组类型的二维指针。
        int (*p)[2][3]=bh;

玖.结构体(009StructureAndEnumeration)

    结构体的基本概念(basic-concepts.cpp)
        结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。
        使用结构体有两个步骤：
            1）定义结构体描述（类型）
            2）创建结构体变量
        定义结构体描述
            语法:
                struct 结构体名 {
                    成员一的数据类型  成员名一;
                    成员二的数据类型  成员名二;
                    成员三的数据类型  成员名三;
                    ......
                    成员n的数据类型  成员名n;
                };
            注意：
                结构体名是标识符。
                结构体的成员可以是任意数据类型。
                定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。
                结构体成员可以用C++的类（如string），但是不提倡。
                在C++中，结构体中可以有函数，但是不提倡。
                在C++11中，定义结构体的时候可以指定缺省值。
        创建结构体变量
            创建结构体变量的语法：
                struct 结构体名 结构体变量名;
            也可以为结构体成员赋初始值。
                struct 结构体名 结构体变量名={成员一的值, 成员二的值,......, 成员n的值};
            C++11可以不写等于号。
            如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0。
                struct 结构体名 结构体变量名={0};
            注意：
                在C++中，struct关键字可以不写。
                可以在定义结构体的时候创建结构体变量。
        使用结构体
            在C++程序中，用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。
            语法：结构体变量名.结构体成员名;
        占用内存的大小
            用sizeof运算符可以得到整个结构体占用内存的大小。
            注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和。
            内存对齐：#pragma pack(字节数)
            合理使用内存对齐规则，某些节省内存的做法可能毫无意义。
        清空结构体
            创建的结构体变量如果没有初始化，成员中有垃圾值。
            用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）
            bzero()函数也可以。
        复制结构体
            用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。
            也可以直接用等于号（只适用于C++基本数据类型）。
        
    结构体指针(structure-pointer.cpp)
        结构体是一种自定义的数据类型，用结构体可以创建结构体变量。
        基本语法
            在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：
                struct st_girl girl;         // 声明结构体变量girl。
                struct st_girl *pst=&girl;  // 声明结构体指针，指向结构体变量girls。
            通过结构体指针访问结构体成员，有两种方法：
                (*指针名).成员变量名    // (*pst).name和(*pst).age 
            或者：
                指针名->成员变量名    // pst->name和*pst->age 
            在第一种方法中，圆点.的优先级高于*，(*指针名)两边的括号不能少。如果去掉括号写成(*指针名).成员变量名，那么相当于*(指针名.成员变量名)，意义就完全不一样了。
            在第二种方法中，->是一个新的运算符。
            上面的两种方法是等效的，程序员通常采用第二种方法，更直观。
            注意：与数组不一样，结构体变量名没有被解释为地址。
        用于函数的参数
            如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针。
            如果不希望在函数中修改结构体变量的值，可以对形参加const约束。
        用于动态分配内存
            用结构体指针指向动态分配的内存的地址。
    
    结构体数组(structure-array.cpp)
        结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。
        声明结构体数组的语法：struct 结构体类型 数组名[数组长度];
        初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。
            struct st_girl girls[2]={{"西施",26,43.8,'X',true},{"西瓜",25,52.8,'X',false}};
        使用结构体数组可以用数组表示法，也可以用指针表示法。
        在结构体中嵌入数组和结构体
            super_girl3 sg3 = {"hillary", 36,45,'X',true,{"Ethan","dog"}};
        
    结构体中的指针(basic-concepts.cpp)
        如果结构体中的指针指向的是动态分配的内存地址：
            对结构体用sizeof运算可能没有意义。
            对结构体用memset()函数可能会造成内存泄露。
        C++的字符串string中有一个指针，指向了动态分配内存的地址。
            struct string
            {
                char *ptr;   // 指向动态分配内存的地址。
                ......
            }
        结论:
            在没有动态分配内存之前,是可以用memset清空结构体的
            在动态分配内存之后,就不能用memset清空结构体了,只能逐个成员进行清空处理.
            总之,清空结构体最好是逐个成员都进行清空.
    
    简单链表(linked-list.cpp)
        如果结构体中有一个本结构体的指针，它就是链表。
        最传统写法
            tmp = new st_girl;
            tmp -> no = 1;
            tmp -> name = "西施";
            tmp -> next = nullptr;
        c11标准写法
            tmp = new st_girl;
            *(tmp) = {1,"西施",nullptr};
        在new时指定节点初始值
            tmp = new st_girl({1,"西施",nullptr});
        注意:
            新分配的节点next指针一般为空,如果需要指向哪个节点在之后赋予其.
        链表是数据结构课程中的重点,但本章节的目标是cpp,不是数据结构,所以点到即止,为链表有初步的认识即可.
        
    共同体(union.cpp)
        共同体能够存储不同的数据类型，但是，在同一时间只能存储其中的一种类型。
        注意：
            共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐）。
            全部的成员使用同一块内存。
            共同体中的值为最后被赋值的那个成员的值。
            匿名共同体没有名字，可以在定义的时候创建匿名共同体变量，也可以嵌入结构体中。
        共同体常用于节省内存的场景（嵌入式系统）。
        
    枚举(enumeration.cpp)
        之前章节学习过创建常量的两种方法(宏常量和const常量),枚举也是一种创建符号常量的方法。
        枚举的语法：
            enum 枚举名 { 枚举量1 , 枚举量2 , 枚举量3, ......, 枚举量n };
        例如：
            enum colors { red , yellow , blue };
        这条语句完成了两项工作：
            让colors成了一种新的枚举类型的名称，可以用它创建枚举变量。
            将red、yellow、blue作为符号常量，默认值是整数的0、1、2。
        注意：
            用枚举创建的变量取值只能在枚举量范围之内。
            枚举的作用域与变量的作用域相同。
            可以显式的设置枚举量的值（必须是整数）,默认是 {red=0, yellow=1, blue=2}
                enum colors {red=1,yellow=2,blue=3};
            可以只显式的指定某些枚举量的值（枚举量的值可以重复）。
                enum colors {red=10,yellow,blue};
            可以将整数强制转换成枚举量，语法：枚举类型(整数)

拾.引用(010Reference)

    引用的基本概念(basic-concepts.cpp)
        引用变量是C++新增的复合类型,c语言中没有.
        引用是已定义的变量的别名。
        引用的主要用途是用作函数的形参和返回值。
        声明/创建引用的语法：数据类型 &引用名=原变量名;
        注意：
            引用的数据类型要与原变量名的数据类型相同。
            引用名和原变量名可以互换，它们值和内存单元是相同的。
            必须在声明引用的时候初始化，初始化后不可改变。
            C和C++用&符号来指示/取变量的地址，C++给&符号赋予了另一种含义。
        引用的本质
            引用是指针常量的伪装。
            引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。

            变量是什么？变量就是一个在程序执行过程中可以改变的量。
            换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。
            在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。
            所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。
            程序员拥有引用，但编译器仅拥有指针（地址）。
            引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。
            引用和指针本质上没有区别。
        引用用于函数的参数
            把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名。
            这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）
            引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。
                1）传引用的代码更简洁。
                2）传引用不必使用二级指针。
                3）引用的属性和特别之处。
            二级指针的传递改用引用传递
        引用的形参和const
            如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量。
            什么时候将创建临时变量呢？
                引用是const。
                数据对象的类型是正确的，但不是左值。
                数据对象的类型不正确，但可以转换为正确的类型。
            结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。
            将引用形参声明为const的理由有三个：
                使用const可以避免无意中修改数据的编程错误。
                使用const使函数能够处理const和非const实参，否则将只能接受非const实参。
                使用const，函数能正确生成并使用临时变量。
            左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。
            非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。
            总之左值就是可以出现在赋值语句 = 左边的量或值,非左值就是赋值语句 = 右边的量或值.
            如下:
                int& a = 8;
                这个语法是报错的, 因为引用a的值必须是变量,不能是一个常量.
                const int& a = 8;
                但是将它声明为const就可以,是因为C++将创建临时变量，让常量引用指向临时变量,即:
                int tmp = 8;
                const int& a = tmp;
            自结论:
                作为函数参数,如果是传值的方法,实参可以是常量也可以是变量
                如果是传地址或传引用,实参就一定要用变量.

    引用用于函数的返回值(function-return-reference.cpp)
        传统的函数返回机制与值传递类似。
        函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值。
            double m = sqrt(36);      // sqrt()是求平方根函数。
        sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。
            cout << sqrt(25);
        sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout。
        如果返回的是一个结构体，将把整个结构体拷贝到临时的位置。
        如果返回引用不会拷贝内存。
        语法：
            返回值的数据类型& 函数名(形参列表);
        注意：
            如果返回局部变量的引用，其本质是野指针，后果不可预知。
            可以返回函数的引用形参、类的成员、全局变量、静态变量。
            返回引用的函数是被引用的变量的别名，将const用于引用的返回类型。
        各种形参的使用场景
            传值、传地址和传引用的指导原则《C++ Primer Plus》
            1）如果不需要在函数中修改实参
                如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。
                如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。
                如果实参是较大的结构，则使用const指针或const引用。
                如果实参是类，则使用const引用，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。
            2）如果需要在函数中修改实参
                如果实参是内置数据类型，则使用指针。只要看到func(&x)的调用，表示函数将修改x。
                如果实参是数组，则只能使用指针。
                如果实参是结构体，则使用指针或引用。
                如果实参是类，则使用引用。
                当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。
                例如：对于基本类型，cin使用引用，因此可以使用cin>>a，而不是cin>>&a。
        函数的默认参数:
            默认参数是指调用函数的时候，如果不书写实参，那么将使用的一个缺省值。
            语法：
                返回值 函数名(数据类型 参数=值, 数据类型 参数=值,……);
            注意：
                如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。
                函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。
                调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。
        函数重载
            函数重载（函数多态）是指设计一系列同名函数，让它们完成相同（似）的工作。
            C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。
                #1    int func(short a  ,string b);
                #2    int func(int a    ,string b);
                #3    int func(double a,string b);
                #4    int func(int a    ,string b, int len);
                #5    int func(string b , int a);
            调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。
            在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。
            注意：
                使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。
                引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征。
                如果重载函数有默认参数，调用函数时，可能导致匹配失败。
                const不能作为函数重载的特征。
                返回值的数据类型不同不能作为函数重载的特征。
                C++的名称修饰：编译时，对每个函数名进行加密，替换成不同名的函数。
                    void MyFunctionFoo(int,float);
                    void MyFunctionFoo(long,float);
                    ?MyFunctionFoo@@YAXH(int,float);
                    #void MyFunctionFoo^$@(long,float);
        内联函数
            C++将内联函数的代码组合到程序中，可以提高程序运行的速度。
            语法：在函数声明和定义前加上关键字inline。
            通常的做法是将函数声明和定义写在一起。
            注意：
                内联函数节省时间，但消耗内存。
                如果函数过大，编译器可能不将其作为内联函数。
                内联函数不能递归。
            自结论:
                内联函数一般在较少代码块或测试时应用.

拾壹.课程巩固(011CourseConsolidation)

    第一章节(chapter_one)
    第二章节(chapter_two)
    第三章节(chapter_three)
    第四章节(chapter_four)
    第五章节(chapter_five)
        总共以上五个章节,详见视频:
            https://ke.qq.com/webcourse/index.html?r=1693747928895#cid=5855339&term_id=106263629&taid=14191199017064555&type=3072&source=PC_COURSE_DETAIL&vid=387702307788503566
        详见章节:
            课后作业(一)
            课后作业(二)
            课后作业(三)
            课后作业(四)
            课后作业(五)

拾贰.类(012Class)

    类基础(class_basic)
        从结构体到类
            对面向对象编程来说，一切都是对象，对象用类来描述。
            类把对象的数据和操作数据的方法作为一个整体考虑。
            定义类的语法：
                class 类名
                {
                    public:
                    成员一的数据类型  成员名一;
                    成员二的数据类型  成员名二;
                    成员三的数据类型  成员名三;
                    ......
                    成员n的数据类型  成员名n;
                };
            注意：
                类的成员可以是变量，也可以是函数。
                类的成员变量也叫属性。
                类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。
                用类定义一个类的变量叫创建（或实例化）一个对象。
                对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。
        类的访问权限
            类的成员有三种访问权限：public、private和protected，分别表示公有的、私有的和受保护的。
            在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。
            在类的外部（定义类的代码之外），只能访问public成员，不能访问private、protected成员。
            在一个类体的定义中，private 和 public 可以出现多次。
            结构体的成员缺省为public，类的成员缺省为private。
            private的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为public。
        简单使用类
            1）类的成员函数可以直接访问该类其它的成员函数（可以递归）。
            2）类的成员函数可以重载，可以使用默认参数。
            3）类指针的用法与结构体指针用法相同。
            4）类的成员可以是任意数据类型（类中枚举）。
            5）可以为类的成员指定缺省值（C++11标准）。
            6）类可以创建对象数组，就像结构体数组一样。
            7）对象可以作为实参传递给函数，一般传引用。
            8）可以用new动态创建对象，用delete释放对象。
            9）在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。
            10）对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。
            11）对类和对象用sizeof运算意义不大，一般不用。
            12）用结构体描述纯粹的数据，用类描述对象。
            13）在类的声明中定义的函数都将自动成为内联函数;在类的声明之外定义的函数如果使用了inline限定符,也是内联函数
            14）为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。
            15）类的分文件编写。
    
    构造函数(constructor_func)
        构造函数：在创建对象时，自动的进行初始化工作。
        析构函数：在销毁对象前，自动的完成清理工作。
        1）构造函数
            语法：类名(){......}
                访问权限必须是public。
                函数名必须与类名相同。
                没有返回值，不写void。
                可以有参数，可以重载，可以有默认参数。
                创建对象时只会自动调用一次，不能手工调用。
        2）析构函数
            语法：~类名(){......}
                访问权限必须是public。
                函数名必须在类名前加~。
                没有返回值，也不写void。
                没有参数，不能重载。
                销毁对象前只会自动调用一次，但是可以手工调用。
        注意：
            如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。
            如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。
            创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。
            创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）
            在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
            接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。
                CGirl girl =10;
            以下两行代码有本质的区别：
                CGirl girl = CGirl("西施"20);  // 显式创建对象。
                CGirl girl;                   // 创建对象。
                girl = CGirl("西施"20);        // 创建匿名对象，然后给现有的对象赋值。
            用new/delete创建/销毁对象时，也会调用构造/析构函数。
            不建议在构造/析构函数中写太多的代码，可以调用成员函数。
            除了初始化，不建议让构造函数做太多工作（只能成功不会失败）。
            C++11支持使用统一初始化列表。
                CGirl girl = {"西施"20};
                CGirl girl  {"西施"20};
                CGirl* girl = new CGirl{ "西施"20 };
            如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构成员类。
    
    拷贝构造函数(copy_constructor)
        用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。
        如果类中没有定义拷贝构造函数，编译器将提供一个默认的拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
        用一个已存在的对象创建新的对象语法：
            类名 新对象名(已存在的对象名);
            类名 新对象名=已存在的对象名;
            拷贝构造函数的语法：
                类名(const 类名& 对象名){......}
        注意：
            访问权限必须是public。
            函数名必须与类名相同。
            没有返回值，不写void。
            如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。
            以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。
            函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）。
            拷贝构造函数可以重载，可以有默认参数。
                类名(......,const 类名& 对象名,......){......}
            如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。
    
    初始化列表(initializer_cuslist)
        构造函数的执行可以分成两个阶段：初始化阶段和计算阶段（初始化阶段先于计算阶段）。
            初始化阶段：全部的成员都会在初始化阶段初始化。
            计算阶段：一般是指用于执行构造函数体内的赋值操作。
        构造函数除了参数列表和函数体之外，还可以有初始化列表。
        初始化列表的语法：
            类名(形参列表):成员一(值一), 成员二(值二),..., 成员n(值n)
            {......}
        注意：
            1）如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。
            2）初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。
            3）初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。
            4）如果成员是类，初始化列表对性能略有提升。
            5）如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。
            6）如果成员是没有默认构造函数的类，则必须使用初始化列表。
            7）拷贝构造函数也可以有初始化列表。
            8）类的成员变量可以不出现在初始化列表中。
            9）构造函数的形参先于成员变量初始化。
    
    const修饰成员函数(const_decorate_func)
        在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量。
        注意：
            1）mutable可以突破const的限制，被mutable修饰的成员变量，将永远处于可变的状态，在const修饰的函数中，mutable成员也可以被修改。
            2）非const成员函数可以调用const成员函数和非const成员函数。
            3）const成员函数不能调用非const成员函数。
            4）非const对象可以调用const修饰的成员函数和非const修饰的成员函数。
            5）const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数。
        
        这里出现了令人纠结的三个问题：
            1、为什么要保护类的成员变量不被修改？
            2、为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？
            3、到底有没有必要使用const和mutable这两个关键字？
        原因：
            保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。
            并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。
            而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。
            没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。
        
    this指针(this_point)
        如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。
        this指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。
        每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）
        *this可以表示对象。
        如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量。
        
    静态成员(static_member)
        类的静态成员包括静态成员变量和静态成员函数。
        用静态成员可以变量实现多个对象之间的数据共享，比全局变量更安全性。
        用static关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。
        静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符::）。
        静态成员使用类名加范围解析运算符::就可以访问，不需要创建对象。
        如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。
        静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。
        在静态成员函数中，只能访问静态成员，不能访问非静态成员。
        静态成员函数中没有this指针。
        在非静态成员函数中，可以访问静态成员。
        私有静态成员在类外无法访问。
        const静态成员变量可以在定义类的时候初始化。
    
    简单对象模型(simple_object_model)
        在C语言中，数据和处理数据的操作（函数）是分开的。也就是说，C语言本身没有支持数据和函数之间的关联性。
        C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了数据和函数，把数据和函数关联起来。
        对象中维护了多个指针表，表中放了成员与地址的对应关系。
        C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。
            对象内存的大小包括：
                1）所有非静态数据成员的大小；
                2）由内存对齐而填补的内存大小；
                3）为了支持virtual成员而产生的额外负担。
            静态成员变量属于类，不计算在对象的大小之内。
            成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。
            用空指针可以调用没有用到this指针的非静态成员函数。
            对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。
    
    友元(friend_basic)
        如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。
        友元提供了另一访问类的私有成员的方案。友元有三种：
            1）友元全局函数
                在友元全局函数中，可以访问另一个类的所有成员。
            2）友元类
                在友元类所有成员函数中，都可以访问另一个类的所有成员。
                友元类的注意事项：
                    友元关系不能被继承。
                    友元关系是单向的，不具备交换性。
                    若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。
            3）友元成员函数(这个有点麻烦，代码实例中没有演示)
                在友元成员函数中，可以访问另一个类的所有成员。
                    声明和定义的顺序如下：
                        class CGirl;            // 前置声明。   
                        class CBoy { ...... };      // CBoy的定义。
                        class CGirl { ...... };      // CGirl的定义。
                        // 友元成员函数的定义。               
                        void CBoy::func(CGirl &g) { ...... }








拾叁.运算符重载(013Operator)

    运算符重载基础(operator_basic)
        C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。
        例如字符串string用加号（+）拼接、cout用两个左尖括号（<<）输出。
        运算符重载函数的语法：
            返回值 operator运算符(参数列表);
        运算符重载函数的返回值类型要与运算符本身的含义一致。
        非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；
        成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。
        如果同时重载了非成员函数和成员函数版本，会出现二义性。
        注意：
            1）返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）
            2）重载函数参数列表中的顺序决定了操作数的位置。
            3）重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。
            4）如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。
            5）重载函数不能违背运算符原来的含义和优先级。
            6）不能创建新的运算符。
            7）以下运算符不可重载：
                sizeof              sizeof运算符
                .                   成员运算符
                .*                  成员指针运算符
                ::                  作用域解析运算符
                ?:                  条件运算符
                typeid              一个RTTI运算符
                const_cast          强制类型转换运算符
                dynamic_cast        强制类型转换运算符
                reinterpret_cast    强制类型转换运算符
                static_cast         强制类型转换运算符
            8）以下运算符只能通过成员函数进行重载：
                =                   赋值运算符
                ()                  函数调用运算符
                []                  下标运算符
                ->                  通过指针访问类成员的运算符

    重载关系运算符(overloading_relational_operators)
        重载关系运算符（==、!=、>、>=、<、<=）用于比较两个自定义数据类型的大小。
        可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。
    
    重载左移运算符(overloading_left_shift_operators)
        重载左移运算符（<<）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）。
        只能使用非成员函数版本。
        如果要输出对象的私有成员，可以配合友元一起使用。

    重载下标运算符(overloading_subscript_operators)
        如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便。
        下标运算符必须以成员函数的形式进行重载。
        下标运算符重载函数的语法：
            返回值类型 &perator[](参数);
            或者：
            const 返回值类型 &operator[](参数) const;
        使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。
        使用第二种声明方式，[]只能访问而不能修改数组元素。
        在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。
        在重载函数中，可以对下标做合法性检查，防止数组越界。


    重载赋值运算符(overloading_assignment_operators)
        C++编译器可能会给类添加四个函数：
            默认构造函数，空实现。
            默认析构函数，空实现。
            默认拷贝构造函数，对成员变量进行浅拷贝。
            默认赋值函数, 对成员变量进行浅拷贝。
        对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。
        如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。
        如果类中重载了赋值函数，编译器将不提供默认赋值函数。
        重载赋值函数的语法：类名 & operator=(const 类名 & 源对象);
        注意：
            编译器提供的默认赋值函数，是浅拷贝。
            如果对象中不存在堆区内存空间，默认赋值函数可以满足需求，否则需要深拷贝。
            赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。
    
    重载new和delete运算符(overloading_new_del_operators)
        重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）
        建议先学习C语言的内存管理函数malloc()和free()。
        在C++中，使用new时，编译器做了两件事情：
            1）调用标准库函数operator new()分配内存；
            2）调用构造函数初始化内存；
        使用delete时，也做了两件事情：
            1）调用析构函数；
            2）调用标准库函数operator delete()释放内存。
        构造函数和析构函数由编译器调用，我们无法控制，但是，可以重载内存分配函数operator new()和释放函数operator delete()。
            1）重载内存分配函数的语法：void* operator new(size_t size);   
            参数必须是size_t，返回值必须是void*。
            2）重载内存释放函数的语法：void operator delete(void* ptr)   
            参数必须是void *（指向由operator new()分配的内存），返回值必须是void。
            
        重载的new和delete可以是全局函数，也可以是类的成员函数。
        为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。
        编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。
        new[]和delete[]也可以重载。
        
        实现简单的内存池(simple_memory_pool)
            内存池的概念：
                内存池是预先分配的一大块连续的内存空间，连续的内存空间是为了程序在运行的过程中可以扩展。
            使用内存池的目的：
                1）提升分配和归还的效率
                2）减少内存碎片
           

 
    重载括号运算符(overloading_parenthesis_operators)
        括号运算符()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。
        括号运算符重载函数的语法：
            返回值类型 operator()(参数列表);
        注意：
            括号运算符必须以成员函数的形式进行重载。
            括号运算符重载函数具备普通函数全部的特征。
            如果函数对象与全局函数同名，按作用域规则选择调用的函数。
        函数对象的用途：
            1）表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；
            2）函数对象本质是类，可以用成员变量存放更多的信息；
            3）函数对象有自己的数据类型；
            4）可以提供继承体系。

    
    重载一元运算符(overloading_unary_operators)
        可重载的一元运算符。
            1）++ 自增       
            2）-- 自减    
            3）! 逻辑非     
            4）& 取地址
            5）~ 二进制反码  
            6）* 解引用   
            7）+ 一元加    
            8）- 一元求反
        一元运算符通常出现在它们所操作的对象的左边。但是，自增运算符++和自减运算符--有前置和后置之分。
        C++ 规定，重载++或--时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。
        成员函数版：CGirl &operator++();                   // ++前置
        成员函数版：CGirl operator++(int);                 // 后置++
        非成员函数版：CGirl &operator++(CGirl &);          // ++前置
        非成员函数版：CGirl operator++(CGirl &,int);       // 后置++



    自动类型转换(auto_type_conversion)
        对于内置类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度。
            long count = 8;        // int转换为long
            double time = 11;      // int转换为double
            int side = 3.33         // double转换为int的3
        C++不自动转换不兼容的类型，下面语句是非法的：
            int* ptr = 8;
            不能自动转换时，可以使用强制类型转换：
            int* p = (int*)8;
        如果某种类型与类相关，从某种类型转换为类类型是有意义的。
            string str = "我是一只傻傻鸟。";
        在C++中，将一个参数的构造函数用作自动类型转换函数，它是自动进行的，不需要显式的转换。
            CGirl g1(8);          // 常规的写法。
            CGirl g1 = CGirl(8);   // 显式转换。
            CGirl g1 = 8;         // 隐式转换。
            CGirl g1;             // 创建对象。
            g1 = 8;              // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
        注意：
            1）一个类可以有多个转换函数。
            2）多个参数的构造函数，除第一个参数外，如果其它参数都有缺省值，也可以作为转换函数。
            3）CGirl(int)的隐式转换的场景：
                将CGirl对象初始化为int值时。  CGirl g1 = 8;
                将int值赋给CGirl对象时。      CGirl g1; g1 = 8;
                将int值传递给接受CGirl参数的函数时。
                返回值被声明为CGirl的函数试图返回int值时。
                在上述任意一种情况下，使用可转换为int类型的内置类型时。
            4）如果自动类型转换有二义性，编译将报错。
        将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换。explicit关键字用于关闭这种自动特性，但仍允许显式转换。
            explicit CGirl(int bh);
            CGirl g=8;          // 错误。
            CGirl g=CGirl(8);   // 显式转换，可以。
            CGirl g=(CGirl)8;   // 显式转换，可以。
        在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit。


    转换函数(conversion_func)
        构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数。
            语法：operator 数据类型();
        注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数。
        可以让编译器决定选择转换函数（隐式转换），可以像使用强制类型转换那样使用它们（显式转换）。
            int ii=girl;       // 隐式转换。
            int ii=(int) girl;  // 显式转换。
            int ii=int(girl);   // 显式转换。
        如果隐式转换存在二义性，编译器将报错。
        在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以将转换函数声明为显式的。
        还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行。
        int ii=girl.to_int();
        警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。












拾肆.类继承(014ClassInherit)

    继承的基本概念(class_inherit_basic)
        继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。
            语法：
                class 派生类名:［继承方式］基类名
                {
                    派生类新增加的成员
                };
        被继承的类称为基类或父类，继承的类称为派生类或子类。
        继承和派生是一个概念，只是站的角度不同。
        派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能。
        使用继承的场景：
            1) 如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。
            2) 当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。

    继承方式(inherit_mode)
        类成员的访问权限由高到低依次为：public --> protected --> private，public成员在类外可以访问，private成员只能在类的成员函数中访问。
        如果不考虑继承关系，protected成员和private成员一样，类外不能访问。但是，当存在继承关系时，protected和private就不一样了。基类中的protected成员可以在派生类中访问，而基类中的 private成员不能在派生类中访问。
        继承方式有三种：public（公有的）、protected（受保护的）和private（私有的）。它是可选的，如果不写，那么默认为private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限。

            1）基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。
                再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。
                也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。
            2) 不管继承方式如何，基类中的private成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。
            3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private。
            4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。
        由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以，在实际开发中，一般使用public。
        在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。
        使用 using 关键字可以改变基类成员在派生类中的访问权限。
        注意：
            using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。


    继承的对象模型(inherit_obj_model)
        1）创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。
        2）销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。如果手工调用派生类的析构函数，也会调用基类的析构函数。
        3）创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针相同的。
        4）创建派生类对象时，先初始化基类对象，再初始化派生类对象。
        5）在VS中，用cl.exe可以查看类的内存模型。
        6）对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小。
        7）在C++中，不同继承方式的访问权限只是语法上的处理。
        8）对派生类对象用memset()会清空基类私有成员。
        9）用指针可以访问到基类中的私有成员（内存对齐）。
        
        查看对象内存布局的方法：
            cl 源文件名 /d1 reportSingleClassLayout类名
            注意：类名不要太短，否则屏幕会显示一大堆东西，找起来很麻烦。
            例如，查看BBB类，源代码文件是demo01.cpp：
            cl demo01.cpp /d1 reportSingleClassLayoutBBB
            
    
    构造基类(structure_basic_class)
        派生类构造函数的要点如下： 
            1）创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。
            2）如果没以指定基类构造函数，将使用基类的默认构造函数。
            3）可以用初始化列表指明要使用的基类构造函数。
            4）基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。
            5）派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数。


    名字遮蔽与类作用域(name_shield_class_scope)
        如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类上的成员，而不是基类的。
        注意：基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。
        类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。
        在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员可以通过对象访问，也可以通过类访问。
        在成员名前面加类名和域解析符可以访问对象的成员。
        如果不存在继承关系，类名和域解析符可以省略不写。
        当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找。
        如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员。

    
    继承的特殊关系(special_inherit)
        派生类和基类之间有一些特殊关系。
            1）如果继承方式是公有的，派生类对象可以使用基类成员。
            2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。
            3）基类指针可以在不进行显式转换的情况下指向派生类对象。
            4）基类引用可以在不进行显式转换的情况下引用派生类对象。
        注意：
            1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。
            2）可以用派生类构造基类。
            3）如果函数的形参是基类，实参可以用派生类。
            4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。

    
    多继承与虚继承(more_and_virtual_inherit)
        多继承的语法：
            class 派生类名 : [继承方式1] 基类名1, [继承方式2] 基类名2,......
                {
                    派生类新增加的成员
                };
        域名解析符：
            类名::成员
            例如:
            Person::name
        菱形继承: (多继承的一种特殊情况)
            类B和类C继承自类A,类D又继承自类B和类C,这就是菱形继承
        虚继承可以解决菱形继承的二义性和数据冗余的问题。
        有了多继承，就存在菱形继承，有了菱形继承就有虚继承，增加了复杂性。
        不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承。
        如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。















拾伍.类多态(015ClassPolymorphism)
    
    多态的基本概念(polymorphism_base_concept)
        基类指针只能调用基类的成员函数，不能调用派生类的成员函数。
        如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。
        有了虚函数，基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据，基类指针表现出了多种形式，这种现象称为多态。
        基类引用也可以使用多态。
        注意：
            1）只需要在基类的函数声明中加上virtual关键字，函数定义时不能加。
            2）在派生类中重定义虚函数时，函数特征要相同。
            3）当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。
            4）在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。
            5）如果要在派生类中重新定义基类的函数，则将基类函数设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。


    多态的应用场景(polymorphism_application_scenario)

    多态的对象模型(polymorphism_obj_model)
        类的普通成员函数的地址是静态的，在编译阶段已指定。
        如果基类中有虚函数，对象的内存模型中有一个虚函数表，表中存放了基类的函数名和地址。
        如果派生类中重定义了基类的虚函数，创建派生类对象时，将用派生类的函数取代虚函数表中基类的函数。
        
        C++中的多态分为两种：静态多态与动态多态。
        静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。
        动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。


    如何析构派生类(destruct_derived_classes)
        构造函数不能继承，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。
        析构函数不能继承，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。
        派生类的析构函数在执行完后，会自动执行基类的析构函数。
        如果手工的调用派生类的析构函数，也会自动调用基类的析构函数。
        析构派生类的要点如下：
            1）析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。
            2）析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的：
                delete ptr;
                ptr=nulllptr;
            3）用基类指针指向派生类对象时，delete基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。
            4）C++编译器对虚析构函数做了特别的处理。
            5）对于基类，即使它不需要析构函数，也应该提供一个空的虚析构函数。
            6）赋值运算符函数不能继承，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参。
            7）友元函数不是类成员，不能继承。


    纯虚函数和抽象类(pure_virtual_func_abstract_class)
        纯虚函数是一种特殊的虚函数，在某些情况下，基类中不能对虚函数给出有意义的实现，把它声明为纯虚函数。
        纯虚函数只有函数名、参数和返回值类型，没有函数体，具体实现留给该派生类去做。
        语法：
            virtual 返回值类型 函数名 (参数列表)=0;
        纯虚函数在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持多态性。
        含有纯虚函数的类被称为抽象类，不能实例化对象，可以创建指针和引用。
        派生类必须重定义抽象类中的纯虚函数，否则也属于抽象类。
        基类中的纯虚析构函数也需要实现。
        有时候，想使一个类成为抽象类，但刚好又没有任何纯虚函数，怎么办？
            方法很简单：在想要成为抽象类的类中声明一个纯虚析构函数。

    运行阶段类型识别(run_phase_type_identification)
        运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，只适用于包含虚函数的类。
        基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。
        dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。
        语法：
            派生类指针 = dynamic_cast<派生类类型 *>(基类指针);
        如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。
        注意：
            1）dynamic_cast只适用于包含虚函数的类。
            2）dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。
            3）dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。

    
    typeid运算符和type_info类(typeid_and_typeinfoclass)
        typeid运算符用于获取数据类型的信息。
        语法一：
            typeid(数据类型);
        语法二：
            typeid(变量名或表达式);
        typeid运算符返回type_info类（在头文件<typeinfo>中定义）的对象的引用。
        type_info类的实现随编译器而异，但至少有name()成员函数，该函数返回一个字符串，通常是类名。
        type_info重载了==和!=运算符，用于对类型进行比较。
        注意：
            1）type_info类的构造函数是private属性，也没有拷贝构造函数，所以不能直接实例化，只能由编译器在内部实例化。
            2）不建议用name()成员函数返回的字符串作为判断数据类型的依据。（编译器可能会转换类型名）
            3）typeid运算符可以用于多态的场景，在运行阶段识别对象的数据类型。
            4）假设有表达式typeid(*ptr)，当ptr是空指针时，如果ptr是多态的类型，将引发bad_typeid异常。











拾陆.函数模版(016FuncTemplate)
    
    自动推导类型auto(auto_deduce_type)
        在C语言和C++98中，auto关键字用于修饰变量（自动存储的局部变量）。
        在C++11中，赋予了auto全新的含义，不再用于修饰变量，而是作为一个类型指示符，指示编译器在编译时推导auto声明的变量的数据类型。
        语法：auto 变量名 = 初始值;
        在Linux平台下，编译需要加-std=c++11参数。
        注意：
            1）auto声明的变量必须在定义时初始化。
            2）初始化的右值可以是具体的数值，也可以是表达式和函数的返回值等。
            3）auto不能作为函数的形参类型。
            4）auto不能直接声明数组。
            5）auto不能定义类的非静态成员变量。
        不要滥用auto，auto在编程时真正的用途如下：
            1）代替冗长复杂的变量声明。
            2）在模板中，用于声明依赖模板参数的变量。
            3）函数模板依赖模板参数的返回值。
            4）用于lambda表达式中。

    函数模版的基本概念(func_template_basic)
        函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。
        编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。
        生成函数定义的过程被称为实例化。
        创建交换两个变量的函数模板：
            template <typename T>
            void Swap(T &a, T &b)
            {
                T tmp = a;
                a = b;
                b = tmp;
            }
        在C++98添加关键字typename之前，C++使用关键字class来创建模板。
        如果考虑向后兼容，函数模板应使用typename，而不是class。
        函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定。
    
    
    函数模版的注意事项(func_template_precautions)
        1）可以为类的成员函数创建模板，但不能是虚函数和析构函数。
        2）使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上。
        3）使用函数模板时，推导的数据类型必须适应函数模板中的代码。
        4）使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。
        5）函数模板支持多个通用数据类型的参数。
        6）函数模板支持重载，可以有非通用数据类型的参数。


    函数模板的具体化(func_template_specific)
        可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。
        具体化（特例化、特化）的语法：
            template<> void 函数模板名<数据类型>(参数列表)
            template<> void 函数模板名 (参数列表)
            {
            // 函数体。
            }
        对于给定的函数名，可以有普通函数、函数模板和具体化的函数模板，以及它们的重载版本。
        编译器使用各种函数的规则：
            1）具体化优先于常规模板，普通函数优先于具体化和常规模板。
            2）如果希望使用函数模板，可以用空模板参数强制使用函数模板。
            3）如果函数模板能产生更好的匹配，将优先于普通函数。


    函数模板高级(func_template_advanced)
        1）decltype关键字
            在C++11中，decltype操作符，用于查询表达式的数据类型。
                语法：decltype(expression) var;
            decltype分析表达式并得到它的类型，不会计算执行表达式。函数调用也一种表达式，因此不必担心在使用decltype时执行了函数。
            decltype推导规则（按步骤）：
                1）如果expression是一个没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定符。
                2）如果expression是一个函数调用，则var的类型与函数的返回值类型相同（函数不能返回void，但可以返回void *）。
                3）如果expression是一个左值（能取地址）(要排除第一种情况)、或者用括号括起来的标识符，那么var的类型是expression的引用。
                4）如果上面的条件都不满足，则var的类型与expression的类型相同。
            如果需要多次使用decltype，可以结合typedef和using。
        2）函数后置返回类型
                int func(int x,double y);
            等同：
                auto func(int x,double y) -> int;
            将返回类型移到了函数声明的后面。
            auto是一个占位符（C++11给auto新增的角色）, 为函数返回值占了一个位置。
            这种语法也可以用于函数定义：
                auto func(int x,double y) -> int
                {
                    // 函数体。
                }
        3）C++14的auto关键字
            C++14标准对函数返回类型推导规则做了优化，函数的返回值可以用auto，不必尾随返回类型。
            示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template <typename T1, typename T2>
            auto func(T1 x, T2 y) -> decltype(x + y)
            {
                decltype(x+y)  tmp = x + y;
                cout << "tmp=" << tmp << endl;
                return tmp;
            }
            
            int main()
            {
                func(3, 5.8);
            }













拾柒.类模版(017ClassTemplate)
    
    模板类的基本概念(class_template_basic)
        类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。
        使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义。
        语法：
            template <class T>
            class 类模板名
            {
                类的定义;
            };
        函数模板建议用typename描述通用数据类型，类模板建议用class。
        注意：
            1）在创建对象的时候，必须指明具体的数据类型。
            2）使用类模板时，数据类型必须适应类模板中的代码。
            3）类模板可以为通用数据类型指定缺省的数据类型（C++11标准的函数模板也可以）。
            4）模板类的成员函数可以在类外实现。
            5）可以用new创建模板类对象。
            6）在程序中，模板类的成员函数使用了才会创建。
        
    模版类的示例-栈(template_class_stack)
    模版类的示例-数组(template_class_array)
        类模板可以有非通用类型参数：
            1）通常是整型（C++20标准可以用其它）；
            2）实例化模板时必须用常量表达式；
            3）模板中不能修改参数的值；
            4）可以为非通用类型参数提供默认值。
        优点：在栈上分配内存，易维护，执行速度快，合适小型数组。
        缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类。
        构造函数的方法更通用，因为数据的大小是类的成员（而不是硬编码），可以创建数组大小可变的类。

    嵌套和递归使用模版类(joint_and_recursive_use_of_templates)
        在C++11之前，嵌套使用模板类的时候，> >之间要加空格。
        
    模版类的具体化(template_class_specific)
        模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。
        语法请见示例程序。
        具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。
        具体化的模板类，成员函数类外实现的代码应该放在源文件中。
    
    模板类与继承(template_class_inherit)
        1）模板类继承普通类（常见）。
        2）普通类继承模板类的实例化版本。
        3）普通类继承模板类。(常见)
        4）模板类继承模板类。
        5）模板类继承模板参数给出的基类（不能是模板类）。
        
        1）模板类继承普通类
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            class AA     // 普通类AA。
            {
            public:
            int m_a;
            AA(int a) :m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            template<class T1, class T2>
            class BB:public AA      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y,int a) : AA(a) , m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            int main()
            {
            BB<int, string> bb(8, "我是一只傻傻鸟。",3);
            bb.func2();
            bb.func1();
            }
        
        2）普通类继承模板类的实例化版本
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            class AA:public BB<int,string>     // 普通类AA。
            {
            public:
            int m_a;
            AA(int a,int x,string y) : BB(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            AA aa(3,8, "我是一只傻傻鸟。");
            aa.func1();
            aa.func2();
            }
        
        3）普通类继承模板类。
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            template<class T1, class T2>
            class AA:public BB<T1,T2>     // 普通类AA变成了模板类，才能继承模板类。
            {
            public:
            int m_a;
            AA(int a, const T1 x, const T2 y) : BB<T1,T2>(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            AA<int,string> aa(3,8, "我是一只傻傻鸟。");
            aa.func1();
            aa.func2();
            }

        4）模板类继承模板类。
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            template<class T1, class T2>
            class AA:public BB<T1,T2>     // 普通类AA变成了模板类，才能继承模板类。
            {
            public:
            int m_a;
            AA(int a, const T1 x, const T2 y) : BB<T1,T2>(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            template<class T, class T1, class T2>
            class CC :public BB<T1, T2>   // 模板类继承模板类。
            {
            public:
            T m_a;
            CC(const T a, const T1 x, const T2 y) : BB<T1, T2>(x, y), m_a(a) { cout << "调用了CC的构造函数。\n"; }
            void func3() { cout << "调用了func3()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            CC<int,int,string> cc(3,8, "我是一只傻傻鸟。");
            cc.func3();
            cc.func2();
            }
        
        5）模板类继承模板参数给出的基类
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            class AA {
            public:
            AA()         { cout << "调用了AA的构造函数AA()。\n"; }
            AA(int a) { cout << "调用了AA的构造函数AA(int a)。\n"; }
            };
            
            class BB {
            public:
            BB()         { cout << "调用了BB的构造函数BB()。\n"; }
            BB(int a) { cout << "调用了BB的构造函数BB(int a)。\n"; }
            };
            
            class CC {
            public:
            CC()         { cout << "调用了CC的构造函数CC()。\n"; }
            CC(int a) { cout << "调用了CC的构造函数CC(int a)。\n"; }
            };
            
            template<class T>
            class DD {
            public:
            DD()         { cout << "调用了DD的构造函数DD()。\n"; }
            DD(int a) { cout << "调用了DD的构造函数DD(int a)。\n"; }
            };
            
            template<class T>
            class EE : public T {          // 模板类继承模板参数给出的基类。
            public:
            EE() :T()           { cout << "调用了EE的构造函数EE()。\n"; }
            EE(int a) :T(a) { cout << "调用了EE的构造函数EE(int a)。\n"; }
            };
            
            int main()
            {
            EE<AA> ea1;                 // AA作为基类。
            EE<BB> eb1;                 // BB作为基类。
            EE<CC> ec1;                 // CC作为基类。
            EE<DD<int>> ed1;      // EE<int>作为基类。
            // EE<DD> ed1;                // DD作为基类，错误。
            }

    模板类与函数(template_class_func)
        模板类可以用于函数的参数和返回值，有三种形式：
            1）普通函数，参数和返回值是模板类的实例化版本。
            2）函数模板，参数和返回值是某种的模板类。
            3）函数模板，参数和返回值是任意类型（支持普通类和模板类和其它类型）。
    
    模板类与友元(template_class_friendship)
        模板类的友元函数有三类：
            1）非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数。
            2）约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。
            3）非约束模板友元：模板类实例化时，如果实例化了n个类，也会实例化n个友元函数，每个实例化的类都拥有n个友元函数。


        1）非模板友元示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class AA    
            {
            T1 m_x;
            T2 m_y;
            public:
            AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            // 非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数，只能在类内实现。
            friend void show(const AA<T1, T2>& a)
            {
            cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            /* friend void show(const AA<int, string>& a);
            friend void show(const AA<char, string>& a);*/
            };
            
            //void show(const AA<int, string>& a)
            //{
            //    cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            //}
            //
            //void show(const AA<char, string>& a)
            //{
            //    cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            //}
            
            int main()
            {
            AA<int, string> a(88, "我是一只傻傻鸟。");
            show(a);
            
                AA<char, string> b(88, "我是一只傻傻鸟。");
                show(b);
            }
        
        2）约束模板友元示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            // 约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。
            template <typename T>
            void show(T& a);                                                 // 第一步：在模板类的定义前面，声明友元函数模板。
            
            template<class T1, class T2>
            class AA    // 模板类AA。
            {
            friend void show<>(AA<T1, T2>& a);          // 第二步：在模板类中，再次声明友元函数模板。
            T1 m_x;
            T2 m_y;
            
            public:
            
                AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template<class T1, class T2>
            class BB    // 模板类BB。
            {
            friend void show<>(BB<T1, T2>& a);          // 第二步：在模板类中，再次声明友元函数模板。
            T1 m_x;
            T2 m_y;
            
            public:
            
                BB(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template <typename T>                                 // 第三步：友元函数模板的定义。
            void show(T& a)
            {
            cout << "通用：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>                                                    // 第三步：具体化版本。
            void show(AA<int, string>& a)
            {
            cout << "具体AA<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>                                                    // 第三步：具体化版本。
            void show(BB<int, string>& a)
            {
            cout << "具体BB<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            int main()
            {
            AA<int, string> a1(88, "我是一只傻傻鸟。");
            show(a1);         // 将使用具体化的版本。
            
                AA<char, string> a2(88, "我是一只傻傻鸟。");
                show(a2);        // 将使用通用的版本。
            
                BB<int, string> b1(88, "我是一只傻傻鸟。");
                show(b1);         // 将使用具体化的版本。
            
                BB<char, string> b2(88, "我是一只傻傻鸟。");
                show(b2);        // 将使用通用的版本。
            }
        3）非约束模板友元
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            // 非类模板约束的友元函数，实例化后，每个函数都是每个每个类的友元。
            template<class T1, class T2>
            class AA    
            {
            template <typename T> friend void show(T& a);     // 把函数模板设置为友元。
            T1 m_x;
            T2 m_y;
            public:
            AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template <typename T> void show(T& a)                     // 通用的函数模板。
            {
            cout << "通用：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>void show(AA<int, string>& a)                 // 函数模板的具体版本。
            {
            cout << "具体<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            int main()
            {
                AA<int, string> a(88, "我是一只傻傻鸟。");
                show(a);         // 将使用具体化的版本。
        
                AA<char, string> b(88, "我是一只傻傻鸟。");
                show(b);        // 将使用通用的版本。
            }
        
    模板类的成员模板(member_template_class)
        
    将模板类用作参数(params_template_class)














拾捌.Cpp编译链接和命名空间(018CompileLinkNamingSapce)

    编译预处理(compile_processing)
        C++程序编译的过程：预处理 -> 编译（优化、汇编）-> 链接
        预处理指令主要有以下三种：
            包含头文件：#include
            宏定义：#define（定义宏）、#undef（删除宏）。
            条件编译：#ifdef、#ifndef。
        
        1）包含头文件
            #include 包含头文件有两种方式：
                #include <文件名>：直接从编译器自带的函数库目录中寻找文件。
                #include "文件名"：先从自定义的目录中寻找文件，如果找不到，再从编译器自带的函数库目录中寻找。
            #include也包含其它的文件，如：*.h、*.cpp或其它的文件。
            C++98标准后的头文件：
                C的标准库：老版本的有.h后缀；新版本没有.h的后缀，增加了字符c的前缀。例如：老版本是<stdio.h>，新版本是<cstdio>，新老版本库中的内容是一样的。在程序中，不指定std命名空间也能使用库中的内容。
                C++的标准库：老版本的有.h后缀；新版本没有.h的后缀。例如：老版本是<iostream.h>，新版本是<iostream>，老版本已弃用，只能用新版本。在程序中，必须指定std命名空间才能使用库中的内容。
            注意：用户自定义的头文件还是用.h为后缀。
        
        2）宏定义指令
            无参数的宏：#define 宏名  宏内容
            有参数的宏：#define MAX(x,y)  ((x)>(y) ? (x) : (y))    MAX(3,5)  ((3)>(5) ? (3) : (5))
            编译的时候，编译器把程序中的宏名用宏内容替换，是为宏展开（宏替换）。
            宏可以只有宏名，没有宏内容。
            在C++中，内联函数可代替有参数的宏，效果更好。
            C++中常用的宏：
                当前源代码文件名：__FILE__
                当前源代码函数名：__FUNCTION__
                当前源代码行号：__LINE__
                编译的日期：__DATE__
                编译的时间：__TIME__
                编译的时间戳：__TIMESTAMP__
            当用C++编译程序时，宏__cplusplus就会被定义。
        
        3）条件编译
            最常用的两种：#ifdef、#ifndef    if #define  if not #define
            #ifdef 宏名
            程序段一
            #else
            程序段二
            #endif
            含义：如果#ifdef后面的宏名已存在，则使用程序段一，否则使用程序段二。
            #ifndef 宏名
            程序段一
            #else
            程序段二
            #endif
            含义：如果#ifndef后面的宏名不存在，则使用程序段一，否则使用序段二。
        
        4）解决头文件中代码重复包含的问题
            在C/C++中，在使用预编译指令#include的时候，为了防止头文件被重复包含，有两种方式。
            第一种：用#ifndef指令。
                #ifndef _GIRL_
                #define _GIRL_
                //代码内容。
                #endif
            第二种：把#pragma once指令放在文件的开头。
                #ifndef方式受C/C++语言标准的支持，不受编译器的任何限制；
                    而#pragma once方式有些编译器不支持。
                #ifndef可以针对文件中的部分代码；而#pragma once只能针对整个文件。
                #ifndef更加灵活，兼容性好；#pragma once操作简单，效率高。
        
    编译和链接(compile_and_link)
        一、源代码的组织
            头文件（*.h）：#include头文件、函数的声明、结构体的声明、类的声明、模板的声明、内联函数、#define和const定义的常量等。
            源文件（*.cpp）：函数的定义、类的定义、模板具体化的定义。
            主程序（main函数所在的程序）：主程序负责实现框架和核心流程，把需要用到的头文件用#include包含进来。
        二、编译预处理
            预处理的包括以下方面：
            1）处理#include头文件包含指令。
            2）处理#ifdef #else #endif、#ifndef #else #endif条件编译指令。
            3）处理#define宏定义。
            4）为代码添加行号、文件名和函数名。
            5）删除注释。
            6）保留部分#pragma编译指令（编译的时候会用到）。
        三、编译
            将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化和汇编后，编译成若干个目标文件（二进制文件）。
        四、链接
            将编译后的目标文件，以及它们所需要的库文件链接在一起，形成一个整体。
        五、更多细节
            1）分开编译的好处：每次只编译修改过的源文件，然后再链接，效率最高。
            2）编译单个*.cpp文件的时候，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误。（直接和间接包含头文件都可以）
            3）编译单个*.cpp文件的时候，编译器只需要知道名称的存在，不会把它们的定义一起编译。
            4）如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令。
            5）链接的时候，变量、函数和类的定义只能有一个，否则会出现重定义的错误。（如果把变量、函数和类的定义放在*.h文件中，*.h会被多次包含，链接前可能存在多个副本；如果放在*.cpp文件中，*.cpp文件不会被包含，只会被编译一次，链接前只存在一个版本）
            6）把变量、函数和类的定义放在*.h中是不规范的做法，如果*.h被多个*.cpp包含，会出现重定义。
            7）用#include包含*.cpp也是不规范的做法，原理同上。
            8）尽可能不使用全局变量，如果一定要用，要在*.h文件中声明（需要加extern关键字），在*.cpp文件中定义。
            9）全局的const常量在头文件中定义（const常量仅在单个文件内有效）。
            10）*.h文件重复包含的处理方法只对单个的*.cpp文件有效，不是整个项目。
            11）函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在*.h文件中；函数模板和类模板的具体化版本的代码是真实的定义，所以放在*.cpp文件中。
            12）Linux下C++编译和链接的原理与VS一样。
    
    命名空间(naming_space)
        在实际开发中，较大型的项目会使用大量的全局名字，如类、函数、模板、变量等，很容易出现名字冲突的情况。
        命名空间分割了全局空间，每个命名空间是一个作用域，防止名字冲突。
        一、语法
            创建命名空间：
            namespace 命名空间的名字
            {
            // 类、函数、模板、变量的声明和定义。
            }
            创建命名空间的别名：
            namespace 别名=原名;
        二、使用命名空间
            在同一命名空间内的名字可以直接访问，该命名空间之外的代码则必须明确指出命名空间。
            1）运算符::
            语法：命名空间::名字
            简单明了，且不会造成任何冲突，但使用起来比较繁琐。
            2）using声明
            语法：using 命名空间::名字
            用using声明名后，就可以进行直接使用名称。
            如果该声明区域有相同的名字，则会报错。
            3）using编译指令
            语法：using namespace命名空间
            using编译指令将使整个命名空间中的名字可用。如果声明区域有相同的名字，局部版本将隐藏命名空间中的名字，不过，可以使用域名解析符使用命名空间中的名称。
        四、注意事项
            1）命名空间是全局的，可以分布在多个文件中。
            2）命名空间可以嵌套。
            3）在命名空间中声明全局变量，而不是使用外部全局变量和静态变量。
            4）对于using声明，首选将其作用域设置为局部而不是全局。
            5）不要在头文件中使用using编译指令，如果非要使用，应将它放在所有的#include之后。
            6）匿名的命名空间，从创建的位置到文件结束有效。

    类型转换static_cast(type_trans_static_cast)
        C风格的类型转换很容易理解：
        语法：
            (目标类型)表达式或目标类型(表达式);
        C++认为C风格的类型转换过于松散，可能会带来隐患，不够安全。
        C++推出了新的类型转换来替代C风格的类型转换，采用更严格的语法检查，降低使用风险。
        C++新增了四个关键字static_cast、const_cast、reinterpret_cast和dynamic_cast，用于支持C++风格的类型转换。
        C++的类型转换只是语法上的解释，本质上与C风格的类型转换没什么不同，C语言做不到事情的C++也做不到。
        语法：
            static_cast<目标类型>(表达式);
            const_cast<目标类型>(表达式);
            reinterpret_cast<目标类型>(表达式);
            dynamic_cast<目标类型>(表达式);

        一、static_cast
            1）用于内置数据类型之间的转换
                除了语法不同，C和C++没有区别。
                #include <iostream>
                using namespace std;
                
                int main(int argc, char* argv[])
                {
                int    ii = 3;
                long ll = ii;                     // 绝对安全，可以隐式转换，不会出现警告。
                
                    double dd = 1.23;
                    long ll1 = dd;                  // 可以隐式转换，但是，会出现可能丢失数据的警告。
                    long ll2 = (long)dd;              // C风格：显式转换，不会出现警告。
                    long ll3 = static_cast<long>(dd);    // C++风格：显式转换，不会出现警告。
                    cout << "ll1=" << ll1 << ",ll2=" << ll2 << ",ll3=" << ll3 << endl;
                }
            2）用于指针之间的转换
                C风格可以把不同类型的指针进行转换。
                C++不可以，需要借助void *。
                #include <iostream>
                using namespace std;
                
                void func(void* ptr) {   // 其它类型指针 -> void *指针 -> 其它类型指针
                double* pp = static_cast<double*>(ptr);
                }
                
                int main(int argc, char* argv[])
                {
                int ii = 10;
                
                    //double* pd1 = &ii;                      // 错误，不能隐式转换。
                    double* pd2 = (double*) &ii;      // C风格，强制转换。
                    //double* pd3 = static_cast<double*>(&ii);    // 错误，static_cast不支持不同类型指针的转换。
                
                    void* pv = &ii;                               // 任何类型的指针都可以隐式转换成void*。
                    double* pd4 = static_cast<double*>(pv);  // static_cast可以把void *转换成其它类型的指针。
                    func(&ii);
                }
        
        二、const_cast
            static_cast不能丢掉指针（引用）的const和volitale属性，const_cast可以。
            示例：
                #include <iostream>
                using namespace std;
                
                void func(int *ii)
                {}
                
                int main(int argc, char* argv[])
                {
                const int *aa=nullptr;
                int *bb = (int *)aa;                          // C风格，强制转换，丢掉const限定符。
                int* cc = const_cast<int*>(aa);      // C++风格，强制转换，丢掉const限定符。
                
                    func(const_cast<int *>(aa));
                }
        三、reinterpret_cast
            static_cast不能用于转换不同类型的指针（引用）（不考虑有继承关系的情况），reinterpret_cast可以。
            reinterpret_cast的意思是重新解释，能够将一种对象类型转换为另一种，不管它们是否有关系。
            语法：
                reinterpret_cast<目标类型>(表达式);
            <目标类型>和(表达式)中必须有一个是指针（引用）类型。
            reinterpret_cast不能丢掉(表达式)的const或volitale属性。
            应用场景：
                1）reinterpret_cast的第一种用途是改变指针（引用）的类型。
                2）reinterpret_cast的第二种用途是将指针（引用）转换成整型变量。整型与指针占用的字节数必须一致，否则会出现警告，转换可能损失精度。
                3）reinterpret_cast的第三种用途是将一个整型变量转换成指针（引用）。
            示例：
                #include <iostream>
                using namespace std;
                
                void func(void* ptr) {  
                long long ii = reinterpret_cast<long long>(ptr);
                cout << "ii=" << ii << endl;
                }
                
                int main(int argc, char* argv[])
                {
                long long ii = 10;
                
                    func(reinterpret_cast<void *>(ii));
                }
            









拾玖.STL容器和算法(019STLContainerAndAlgorithm)

    string容器(string_container)
        string是字符容器，内部维护了一个动态的字符数组。
        与普通的字符数组相比，string容器有三个优点：
            1）使用的时候，不必考虑内存分配和释放的问题；
            2）动态管理内存（可扩展）；
            3）提供了大量操作容器的API。
        缺点是效率略有降低，占用的资源也更多。
        string类是std::basic_string类模板的一个具体化版本的别名。
        
        构造和析构
            静态常量成员string::npos为字符数组的最大长度（通常为unsigned int的最大值）；
            NBTS（null-terminated string）：C风格的字符串（以空字符0结束的字符串）。
            string类有七个构造函数（C++11新增了两个）：
                1）string(); // 创建一个长度为0的string对象（默认构造函数）。
                2）string(const char *s); // 将string对象初始化为s指向的NBTS（转换函数）。
                3）string(const string &str); // 将string对象初始化为str（拷贝构造函数）。
                4）string(const char *s,size_t n); // 将string对象初始化为s指向的地址后n字节的内容。
                5）string(const string &str,size_t pos=0,size_t n=npos); // 将sring对象初始化为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。
                6）template<class T> string(T begin,T end); // 将string对象初始化为区间[begin,end]内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。
                7）string(size_t n,char c); // 创建一个由n个字符c组成的string对象。
            析构函数~string()释放内存空间。
            C++11新增的构造函数：
                1）string(string && str) noexcept：它将一个string对象初始化为string对象str，并可能修改str（移动构造函数）。
                2）string(initializer_list<char> il)：它将一个string对象初始化为初始化列表il中的字符。
                例如：string ss = { 'h','e','l','l','o' };
            

贰零.智能指针(020SmartPointer)
贰壹.Cpp文件操作(021CppFileOperate)
贰贰.Cpp异常和断言(022CppExceptionAndAssertion)
贰叁.Cpp11新标准(023Cpp11NewStandard)
贰肆.Cpp11线程(024Cpp11Thread)
贰伍.可调用对象的绑定器和包装器(025BinderAndPackaging)









零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;
