博学之, 审问之, 慎思之, 明辨之, 笃行之;
零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;

视频地址: (https://ke.qq.com/course/5855339#term_id=106263629)
         (https://www.bilibili.com/video/BV1o8411x7K3?spm_id_from=333.788.videopod.episodes&vd_source=6122dea75af0b44c85ff18d196f1b32d&p=134)

零.第一个Cpp程序 (helloworld)

    命令行gcc运行:
        指定输出:
            gcc -lstdc++ main.cpp -o test
                生成 test
            ./test
                输出： Hello World！
        不指定输出:
            gcc -lstdc++ main.cpp
                生成 a.out
            ./a.out
                输出： Hello World！
    CLion集成环境：
        Tools ==> CMake ==> Unload CMake Project
        这样会在 cpp 文件中自动提示 Create CMakeLists.txt
        点击它将自动在根目录生成 CMakeLists.txt 配置文件
    
    XCode集成环境：
        Create a new Xcode Project
        macos ==> Command Line Tool
        在项目构建窗口中自行配置项目信息，注意Language 选择 C++ 即可。
    
    后续都将用XCode集成环境进行学习

壹.命名&注释&变量&常量 (001designate&variable&Constant)

    数据是信息的载体,C程序大多时的目的就是为了处理数据.
    数据的分类:
        数字,字符,字符串三种类型:
        字符是单引号,字符串是双引号.
    
    输出数据:
        std::cout               输出各种类型的数据
        <<                      输出操作符,可以拼接多个数据项
        std::endl               也可以用于换行
        using namespace std;    指定缺省的命名空间
    
    注释:
        单行注释: //
        单行注释: /**/
        多行注释可以注释掉单行注释,单行注释也可以注释掉多行注释(牛逼,已经不认识释这个字了)
    
    变量:
        C++中常用的数据类型:
            整数(int)
            浮点数(float,double)
            字符(char)
            字符串(string)
            布尔(bool)
        注意: C++ 中ture输出是用1表示,false用0表示
    
    常量:
        宏常量:
            一般在main函数外面声明,用大写命名,注意宏常量结尾不需要分号
        const修饰的常量:
            在程序的任何地方都可以声明.
        常量值的特点即不能被修改.
    
    标识符的命名:
        C++规定给标识符命名时(变量,常量,函数,结构体,类等),必须遵守以下规则:
            字母,数字,下划线命名.
            命名首位不能是数字.
            命名大小写区分.
            不能以关键字进行命名.
            下划线和大写字母打头的名称,被保留个编译器和其使用的资源使用,可以这么用但是不推荐.因为C++会扩展,过几年就会有新的标准,下划线命名的名称现在不会和新标准冲突,
                并不表示以后也是合法的.所以最好别这么用.
    
    输入数据:
        程序输入数据的方式有多种:
            从控制台命令行的界面中输入.
            从文件中读取.
            从数据库中读取.
            从网络中读取.
        语法:
            std::cin                输入各种类型的数据
            >>                      输入操作符,可以拼接多个数据项
        注意:
            布尔型变量输入时只能填0和非0,非0将转换为1.
            如果命令行中输入的数据和程序中变量的数据类型不匹配.会导致行为的不确定性.

贰.算术运算 (002arithmetic)

    算术运算:
        整数如果除0,程序将异常退出.
        浮点数如果除0,将得到Inf(infinite)
        整数与浮点数进行除法运算时,得到的结果是浮点数
        进行除法运算时,在整数前面加(float)或(double)可以将整数转换为浮点数,这是强制类型转换的结果
        求余运算只能用于整数,且分母不能为0.
    
    自增和自减:
        ++a: 先把变量值加1, 然后再执行表达式.
        a++: 先执行表达式, 再把变量值加1.
        --a: 先把变量值减1, 然后再执行表达式.
        a--: 先执行表达式, 再把变量减1.
    
    赋值运算符:
        =
        +=
        -=
        *=
        /=
        %=
        
    C++11初始化赋值:
        C++ 标准:
            int h = 10;
            int j = (10);
            int k (10);
        
        C++11 标准:
            int h1 = 10;
            int j1 = {10};
            int k1 {10};
    
        注意: 在Linux平台下, 编译需要加 -std=c++11 参数, 否则会报错.

    关系运算:
        用于比较两个表达式的值, 运算的结果为1和0, 即 1-true 和 0-false.
        
        ==
        !=
        <
        <=
        >
        >=
        
       注意:
            std::cout输出关系运算表达式时, 关系表达式要加括号, 否则会报错.
    
    逻辑运算:
        &&
        ||
        !

    逗号运算:
        赋值运算符的结合律(顺序)是从右到左,如:(a = b = 10).
        算术运算的组合方式是从左到右,如:(a * b / c).
        括号优先级除数组下标外是最高的, 可以改变全部运算符的优先级.

叁.条件分支语句(003conditionStatement)

    经典 if else 语句:
        注意事项:
            if和else语句如果只是执行一行语句,那么可以不写花括号,如果是多行语句就不需要写花括号.
    
    三目运算:
        c = (a > b) ? a : b
        
    switch语句:
        注意每个case条件中不要漏掉 break, 如果使用 return 语句, 后面必须跟个值一般return 0即可.

肆.循环语句(004circulateStatement)

    while:
        while(express){
            statement;
        }
    
    循环的跳转:
        break
            跳出(终止)当前循环语句
        continue
            回到当前循环语句的首部
    for:
        for(int i = 0; i < 10; i++) {
            cout << "当前的值是: " << i << endl;
        }
    嵌套循环:
        99乘法表实现.
    do while:
        int a = 10;
        do{
            cout << a++ << endl;
        }while(a < 20);
        和while的区别: 无论条件是否成立都会首先执行一次.
    goto:
        goto语句也被称为无条件转移语句.
        语法:
            cout << "第1个程序员的编号" << endl;
            goto bbb;
            cout << "第2个程序员的编号" << endl;
            cout << "第3个程序员的编号" << endl;
            cout << "第4个程序员的编号" << endl;
            bbb: cout << "第5个程序员的编号" << endl;
        输出结果:
            第1个程序员的编号
            第5个程序员的编号
        建议:
            在实际开发中,goto语句很容易造成程序流程的混乱,对维护工作带来很大压力,所以几乎看到goto语句的应用,也不建议使用.

伍.函数基础(005fundamentalsOfFunc)

    函数声明:
        int maxNum(int a, int b);
    函数定义:
        int maxNum(int a, int b) {
            return a > b ? a : b;
        }
        注意:
            函数的定义和声明可以书写在一起, 如果在一起, 一般在main函数的上面, 如果分开, 一般在main函数上面声明, 在main函数下面定义
            一般开发中都是将它们分开书写, 声明是声明, 定义是定义.
            在同一个程序中, 函数只需要声明和定义一次, 也可以多次声明, 但只能定义一次;
            函数的声明必须和定义的一致(返回值类型,函数名,参数列表), 否则程序将认定他们不是同一个函数.
    函数调用:
        cout << "man(5,8) = " << maxNum(5,8) << endl;
        注意:
            如果函数的重点是实现功能, 不关心返回值, 返回值的数据类型为void, return后面直接分号结束即可.
            声明函数的代码必须放在调用之前, 定义函数的代码可以放在调用之后.
            main函数不能被调用
    变量的作用域:
        注意:
            变量分全局和局部两种, 在全部函数外部定义的是全局变量.
            在头文件中定义的是全局变量.
            在函数和语句块内部定义的是局部变量.
            函数参数就是该函数的一种局部变量.
            函数内部用static修饰的是静态局部变量,简称静态变量.
                静态变量拥有和程序相同的生命周期,并且只会被初始化一次.
                当程序想要使用全局变量时,可以根据场景考虑优先使用静态变量.
                如果在代码块内部的局部变量和全局变量重名了, 可以通过 :: 来指定使用全局变量.
            for循环初始化语句中定义的变量只作用于for循环的语句块.
    函数参数传递:
        实参:
        形参:
    函数分文件编写:
        函数分文件编写:
            头文件(*.h | *.hpp)
                需要包含的头文件, 指定命名空间, 声明全局变量, 函数的声明, 数据结构和类的声明等...
            源文件(*.c | *.cpp)
                函数的定义, 类的定义.
            主程序(main函数)
                程序的核心流程, 需要用 #include "头文件名" 把头文件包含进来.
        注意:
            #include "tools.h"
                包含自定义的头文件使用双引号
            #include <iostream>
                包含系统的头文件使用尖括号
        编译:
            mac是集成开发环境,不需要写入编译指令.
            linux系统下,把全部的源文件,一起编译,如: gcc -o main main.cpp tools.cpp funcs.cpp
    递归函数:
        int recursion(int x){
            if (x == 0) return 0;
            return x + recursion(x-1);
        };

陆.C++数据类型(006dataType)

    C++四种基本数据类型:
        整数(int)
        浮点数(float/double)
        字符(char)
        布尔(bool)
    
    sizeof
        sizeof运算符是用于求数据类型或变量占用的内存空间
        用于数据类型:
            sizeof(数据类型)
        用于变量:
            sizeof(变量名)
            sizeof 变量名
        注意:
            在32位和64位操作系统中,同一数据类型占用的内存空间可能不一样.
            字符串(string)不是c++的基本数据类型,是c++中的一个类,用sizeof求它占用内存的大小没有意义.
    
    整型的基本概念
        int 是 integer 的简写
        在声明整型变量时,可以在int之前加 signed, unsigned, short, long四种修饰符.
            signed: 有符号的,可以表示正数和负数
            unsigned: 无符号的,只能表示正数
            short: 短的,取值范围小,占用内存少
            long: 长的,取值范围大,占用内存多
        一共四个修饰符,前面两个和后面两个组合,把整数分成了六种类型:
            简写                  全写                      含义                字节占用
            short               (signed short int)        短的                byte 2        
            unsigned short      (unsigned short int)      无符号短的            byte 2          
            int                 (signed int)              适中的               byte 4
            unsigned int        (unsigned int)            无符号适中的          byte 4
            long                (signed long int)         长的                 byte 8
            unsigned long       (unsigned long int)       无符号适中的          byte 8
        根据sizeof的内存大小推断它的取值范围:
            一个位的取值是: 0 1                ==>     2¹ - 1 = 1
            两个位的取值是: 00 01 10 11        ==>     2² - 1 = 3
            三个位的取值是: 000 001 ... 111    ==>     2³ - 1 = 7
        公式:
            一个字节有八个位,表示的数据的取值范围是 2⁸-1, 取值范围是255
            如果占用的内存是两个字节,无符号型的取值范围是 2⁸*2⁸-1
            如果占用的内存是四个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸-1
            如果占用的内存是八个字节,无符号型的取值范围是 2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸*2⁸-1
            如果是有符号,取值范围减半,因为符号占一个位
        注意:
            long在windows下的字节长度和int一样都是4字节, 在mac和linux下是8字节
                所以根据上面的公式推算,long在不同操作系统下的取值范围是不同的.
            整数的取值范围与计算机操作系统和C++语言编译器有关,没有固定值,可以根据它占用的内存大小来推断它的取值范围
            如果超出取值范围,编译不会报错并且程序能够运行,但是结果是错误的,数据会被截断, 如:
                unsigned short int usi1 = 65535 + 1;        ==>         0
                unsigned short int usi2 = 65535 + 2;        ==>         1
                unsigned short int usi3 = 65535 + 3;        ==>         2
                unsigned short int usi100 = 65535 + 100;    ==>         99
            在实际开发中,为了防止超出取值范围,应该保证有足够的空间.
            C++把整型细分为六种数据类型,目的是为了节省内存空间,但是不能省的就不要省,避免出问题.
        
    整数的书写
        整数默认是十进制,一个表示十进制的数字不需要任何特殊的格式
            但是二进制,八进制和十六进制的数字就不一样,为了和十进制的数字分开,在数字前面加了特定的字符前缀.
        十进制:
            int a = 100;                    ==>         100
        二进制(0b|0B):
            二进制由01两个数字组成,书写时必须以0b或0B(不区分大小写)开头.
                int aa = 0b101;             ==>         5
                int bb = -0b110010;         ==>         -50
                int cc = 0B100001;          ==>         33
        八进制(0):
            八进制由 0~7 八个数字组成, 书写时必须以0开头
            在Linux系统中,设备的权限都是用八进制来表示的.
                int aaa = 015;              ==>         13
                int bbb = -0101;            ==>         -65
                int ccc = 0177777;          ==>         65535
        十六进制(0x|0X):
            十六进制由数字 0~9,字母 A~F或a~f(不区分大小写)组成,书写时必须以0x或0X(不区分大小写)开头.
            在C++中,内存地址缺省用十六进制表示.
                int aaaa = 0x2a;            ==>         42
                int bbbb = -0xa0;           ==>         -160
                int cccc = 0xffff;          ==>         65535
        注意:
            在C++中,不要在十进制的前面加0,会被编译器当成八进制.
            还有不要随便删掉别人代码中整数前面的0,C++程序中的任何一个0都不会是多余的.
    
    long-long类型
        在VS中, long是4字节, 32位, 取值范围:-2147483648~2147483647
        在Liunx中, long是8字节, 64位, 取值范围:-9223372036854775808~9223372036854775807
        C++11增加了 long long 类型的整数, 至少64位, 且至少与long一样长.
        在VS中，long long是8字节，64位, 取值范围: -9223372036854775808~9223372036854775807
        在Linux中，long和long long类型都是8字节，64位。
        
    浮点型
        浮点数也成为实数型
        C++浮点型分三种, float(单精度), double(双精度), long double(扩展精度)
        三者的区别是表示有效数字的范围不同:
            float           byte 4          7位有效数字
            double          byte 8          15~16位有效数字
            long double     不小于double     不低于double
        注意：
            在VS和Linux中，long double占用的内存空间分别是8和16字节。
            有效数字包括了小数点前面和后面的数字。
            C++缺省显示6位有效数字，如果要显示更多的有效数字，可以用printf()函数。
            在实际开发中，用整数代替浮点数，整数的运算更快，精度更高。
            在VS中如果书写一个小数, 默认会将该小数当作double类型, 所以如果要声明为float 需要在小数后面加上f表示float.
                如: float x = 123.456789f;
                
    字符型的基本概念
        字符甚至可以理解为和整数是同一种东西.
        字符型(char)占用的内存空间是1字节, 书写用单引号包含.
        在内存中, 不用存放字符本身, 而是存放它对应的编码, 即ASCII码.
        ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）
        是现今最通用的单字节编码方案，包含了33个控制字符（具有特殊含义无法显示的字符）和95个可显示字符。
            'X'     -> 88   01011000
            'a'     -> 97   01100001
            '3'     -> 51   00110011
        概念:
            a）字符的本质是整数，取值范围是0～127。
            b）在书写的时候可以用单引号包含，也可以用整数。
            c）如果书写的时候用单引号包含，程序执行的时候，将把符号解释为对应的整数。
            d）显示的时候，把整数解释为对应的符号，也可以直接显示整数。
            d）可以与整数进行任何运算，运算的时候，书写方式可以用字符，也可以用整数。
            e）C++为什么没有提供1字节的整型？
    
    转义字符
        常用的转义字符:
            0           \0                  NULL,空,给字符型变量赋值可以直接书写0
            10          \n                  换行(LF),将当前位置移到下一行开头
            13          \r                  回车(CR),将当前位置移到本行开头
            9           \t                  水平制表(HT),跳到下一个TAB位置
            11          \v                  垂直制表(VT),跳到下一个TAB位置
            92          \\                  斜线
            
    Cpp11原始字面量
        原始字面量可以直接表示字符串的实际含义, 不需要转移和连接.
        如:
    
    字符串型
        C++风格字符串:   string 变量名 = "字符串内容"
        C风格字符串:     char 变量名[] = "字符串内容"
        C风格字符串的本质是字符数组，C++风格字符串的本质是类，它封装了C风格字符串。
        Cpp风格字符串的常用操作: 赋值, 拼接.
        注意:
            如果字符串的内容都是常量,就不能进行拼接,否则会报错.
                如: string str = "111"+"222"+"333";
            如果内容很长,cpp中还可以分为多行书写.
                如: string str = "111""222""333";
    
    布尔型
        在C和C++中，关系运算和逻辑运算的结果有两种：真和假。
        C语言用0表示假，非0表示真。
        为了提高代码的可读性，C++新增了bool 类型，占用1字节的内存，用true表示真，false表示假。
        bool类型本质上是1字节的整数（unsigned char），取值只有1和0。
        在程序中，书写的时候可以用true和false，编译器把它们解释为1和0。
        如果对bool型变量赋非0的值，将转换成1。
        用cin输入和cout输出的时候，仍是1和0，不会被解释为true和false。
    
    数据类型转换
        计算机进行运算时，要求各操作数的类型具有相同的大小和存储方式。
        在实际开发中，不同类型的数据进行混合运算是基本需求。
        自动类型转换：某些类型的转换编译器可以隐式的进行，不需程序员干预。
            不同数据类型的差别在于取值范围和精度，数据的取值范围越大，精度越高。
            整型从低到高：
                char -> short -> int -> long -> long long
            浮点型从低到高：
                float -> double -> long double
            自动类型转换的规则如下：
                如果一个表达式中出现了不同类型操作数的混合运算，较低类型将自动向较高类型转换。
                当表达式中含有浮点型操作数时，所有操作数都将转换为浮点型。
                赋值运算的右值类型与左值类型不一致时，将右值类型提升/降低为左值类型。
                赋值运算右值超出了左值类型的表示范围，把该右值截断后赋给左值，所得结果可能毫无意义。

        强制类型转换：有些类型的转换需要程序员显式指定。
            为了让程序设计更灵活，转换的目的更清晰，C++提供了强制类型转换的方法，也称之为显式转换。
            强制类型转换的语法：(目标类型)表达式
            注意：
                如果使用强制转换，表示程序员已有明确的目的。
                如果转换的行为不符合理，后果由程序员承担。
                如果采用了强制类型转换，编译的告警信息将不再出现。
                类型转换运算符的优先级比较高，如果没把握就加括号。
        
    数据类型别名
        创建数据类型的别名有两个目的：
            为名称复杂的类型创建别名，方便书写和记忆。
            创建与平台无关的数据类型，提高程序的兼容性。
        语法：
            typedef 原数据类型名 别名;
        C++11还可以用using关键字创建数据类型的别名。
            using 别名=原数据类型名;

柒.指针和内存(007PointersAndMemory)

    指针的基本概念
        变量是内存变量的简称，在C++中，每定义一个变量，系统就会给变量分配一块内存，内存是有地址的。
        C++用运算符&获取变量在内存中的起始地址。
        语法：&变量名
        注意:
            cout输出某些类型时会有bug,显示地址时,会当作字符串显示.
                解决:将地址强转为 void*
                    (void*)&a
                解决:将地址强转为 int
                    (long long)&a
                    因为整数只有是个字节,容纳不下地址,所以要用long long.
            指针默认是用十六进制表示的,不过为了方便我们都用 long long 转为十进制.
        指针变量
            指针变量简称指针，它是一种特殊的变量，专用于存放变量在内存中的起始地址。
            语法：数据类型 *变量名;
            数据类型必须是合法的C++数据类型（int、char、double或其它自定义的数据类型）。
            星号*与乘法中使用的星号是相同的，但是，在这个场景中，星号用于表示这个变量是指针。
        对指针赋值
            不管是整型、浮点型、字符型，还是其它的数据类型的变量，它的地址都是一个十六进制数。
            指针也是有类型的,所以声明指针时需要指定数据类型,不同的类型的指针是有区别的.
            我们用整型指针存放整数型变量的地址；用字符型指针存放字符型变量的地址；
            用浮点型指针存放浮点型变量的地址，用自定义数据类型指针存放自定义数据类型变量的地址等...
            注意
                对指针的赋值操作也通俗的被称为“指向某变量”，被指向的变量的数据类型称为“基类型”。
                    如: int *pa = &a;
                    可以解释为: 让指针pa 指向变量a, 指针的基类型是 int.
                如果指针的数据类型与基类型不符，编译会出现警告。但是，可以强制转换它们的类型。
                    如: int *pa = (int*)&b
        指针占用的内存
            指针也是变量，是变量就要占用内存空间。
            在64位的操作系统中，不管是什么类型的指针，占用的内存都是8字节, 32位系统是4字节.
            在C++中，指针是复合数据类型，复合数据类型是指基于其它类型而定义的数据类型，在程序中，int是整型类型，int*是整型指针类型，int*可以用于声明变量，可以用于sizeof运算符，可以用于数据类型的强制转换，总的来说，把int*当成一种数据类型就是了。
        总结:
            和 golang 一样
            &用于取变量的内存地址, 称为引用运算符 或 地址运算符
            *用于声明指针 和 根据地址取值, 称为间接值 或 解引用运算符
    
    使用指针
        声明指针变量后，在没有赋值之前，里面是乱七八糟的值，这时候不能使用指针。
        指针存放变量的地址，因此，指针名表示的是地址（就像变量名可以表示变量的值一样）
        *运算符被称为间接值或解除引用（解引用）运算符，将它用于指针，可以得到该地址的内存中存储的值.
        *也是乘法符号，C++根据上下文来确定所指的是乘法还是解引用。
        对变量赋初始值是一个好习惯, 一般在定义完之后就应该要赋初始值.
    
    指针用于函数的参数
        如果把函数的形参声明为指针，调用的时候把实参的地址传进去，形参中存放的是实参的地址，在函数中通过解引用的方法直接操作内存中的数据，可以修改实数的值，这种方法被通俗的称为地址传递或传地址。
        值传递：
            函数的形参是普通变量,那么在函数中操作形参不会对实参产生影响.因为值传递是对实参的拷贝.
        地址传递的意义：
            可以在函数中修改实参的值。
                因为cpp中的函数只能有一个返回值, 所以在实际开发中对修改函数中实参值的应用场景非常多
                可以通过函数参数的地址传递对实参进行修改,从而达到类似多个返回值的功能,如(func2)
            减少内存拷贝，提升性能。
                解释:
                    如果用指针变量:
                        int* no = &a2;              int*        内存占用    8字节
                        string* msg = &messages;    string*     内存占用    8字节
                    如果用普通变量:
                        int no = a2;                int         内存占用    4字节
                        string msg = messages;      string      内存占用    40字节
                    so,明白了吧, 普通变量的内存开销是44字节, 而指针的内存开销占用只有16字节
                    即减少了内存的开销或占用, 以提升性能.
    
    用const修饰指针
        常量指针(用的比较多)
            语法：const 数据类型 *变量名;
            不能通过解引用的方法修改内存地址中的值（用原始的变量名是可以修改的）。
            注意：
                指向的变量（对象）可以改变（之前是指向变量a的，后来可以改为指向变量b）。
                一般用于修饰函数的形参，表示不希望在函数里修改内存地址中的值。
                如果用于形参，虽然指向的对象可以改变，但这么做没有任何意义。
                如果形参的值不需要改变，建议加上const修饰，程序可读性更好。
        指针常量
            语法：数据类型* const 变量名;
            指向的变量（对象）不可改变。
            注意：
                在定义的同时必须初始化，否则没有意义。
                可以通过解引用的方法修改内存地址中的值。
                C++编译器把指针常量做了一些特别的处理，改头换面之后，有一个新的名字，叫引用。
        常指针常量
            语法：const 数据类型 * const 变量名;
            指向的变量（对象）不可改变，不能通过解引用的方法修改内存地址中的值。
        总结:
            常量指针：指针指向可以改，指针指向的值不可以更改。
            指针常量：指针指向不可以改，指针指向的值可以更改。
            常指针常量：指针指向不可以改，指针指向的值不可以更改。
    
    void关键字
        在C++中，void表示为无类型，主要有三个用途：
            函数的返回值用void，表示函数没有返回值。
                void func(int a,int b)
                {
                    // 函数体代码。
                    return;
                }
            函数的参数填void，表示函数不需要参数（或者让参数列表空着）。
                int func(void)
                {
                    // 函数体代码。
                    return 0;
                }
            函数的形参用void*，表示接受任意数据类型的指针。
                不能用void声明变量，它不能代表一个真实的变量，但是，用void *可以。
                不能对void *指针直接解引用（需要转换成其它类型的指针）。
                把其它类型的指针赋值给void*指针不需要转换。
                把void *指针赋值给把其它类型的指针需要转换。
    
    Cpp内存模型
        在C++中，程序运行时，内存主要分成四个区，分别是栈、堆、数据段和代码段。
            栈：存储局部变量、函数参数和返回值。
            堆：存储动态开辟内存的变量。
            数据段：存储全局变量和静态变量。
            代码段：存储可执行程序的代码和常量（例如字符常量），此存储区不可修改。
        栈和堆的主要区别：
            1）管理方式不同：栈是系统自动管理的，在出作用域时，将自动被释放；堆需手动释放，若程序中不释放，程序结束时由操作系统回收。
            2）空间大小不同：堆内存的大小受限于物理内存空间；而栈就小得可怜，一般只有8M（可以修改系统参数)。
            3）分配方式不同：堆是动态分配；栈有静态分配和动态分配（都是自动释放）。
            4）分配效率不同：栈是系统提供的数据结构，计算机在底层提供了对栈的支持，进栈和出栈有专门的指令，效率比较高；堆是由C++函数库提供的。
            5）是否产生碎片：对于栈来说，进栈和出栈都有着严格的顺序（先进后出），不会产生碎片；而堆频繁的分配和释放，会造成内存空间的不连续，容易产生碎片，太多的碎片会导致性能的下降。
            6）增长方向不同：栈向下增长，以降序分配内存地址；堆向上增长，以升序分配内存地址。

    动态分配内存new和delete
        使用堆区的内存有四个步骤：
            1）声明一个指针；
            2）用new运算符向系统申请一块内存，让指针指向这块内存；
            3）通过对指针解引用的方法，像使用变量一样使用这块内存；
            4）如果这块内存不用了，用delete运算符释放它。
        申请内存的语法：new 数据类型(初始值);
            如果申请成功，返回一个地址；如果申请失败，返回一个空地址,如果是C++11标准语法还可以: new 数据类型{初始值}.
        释放内存的语法：delete 地址;
            释放内存不会失败。
        注意：
            动态分配出来的内存没有变量名，只能通过指向它的指针来操作内存中的数据。
            如果动态分配的内存不用了，必须用delete释放它，否则有可能用尽系统的内存(重要)。
            动态分配的内存生命周期与程序相同，程序退出时，如果没有释放，系统将自动回收。
            就算指针的作用域已失效，所指向的内存也不会释放。
            用指针跟踪已分配的内存时，不能跟丢。
        
    二级指针
        指针是指针变量的简称，也是变量，是变量就有地址。
        指针用于存放普通变量的地址。
        二级指针用于存放指针变量的地址。
        声明二级指针的语法：数据类型** 指针名;
        使用指针有两个目的：
            传递地址；
            存放动态分配的内存的地址。
        在函数中，如果传递普通变量的地址，形参用指针；传递指针的地址，形参用二级指针。
        把普通变量的地址传入函数后可以在函数中修改变量的值；把指针的地址传入函数后可以在函数中修改指针的值.
        
    空指针
        在C和C++中，用0或NULL都可以表示空指针,声明指针后，在赋值之前，让它指向空，表示没有指向任何地址。
        使用空指针的后果
            如果对空指针解引用，程序会崩溃。
            如果对空指针使用delete运算符，系统将忽略该操作，不会出现异常。所以，内存被释放后，也应该把指针指向空。
            在函数中，应该有判断形参是否为空指针的代码，目的是保证程序的健壮性。
        C++11的nullptr
            用0和NULL表示空指针会产生歧义，C++11建议用nullptr表示空指针，也就是(void *)0。
            NULL在C++中就是0，这是因为在C++中void* 类型是不允许隐式转换成其他类型的，所以之前C++中用0来代表空指针，但是在重载整形的情况下，会出现上述的问题。所以，C++11加入了nullptr，可以保证在任何情况下都代表空指针，而不会出现上述的情况，因此，建议用nullptr替代NULL吧，而NULL就当做0使用。
            注意：在Linux平台下，如果使用nullptr，编译需要加-std=c++11参数。
            
    野指针
        野指针就是指针指向的不是一个有效（合法）的地址。
        在程序中，如果访问野指针，可能会造成程序的崩溃。
        出现野指针的情况主要有三种：
            1）指针在定义的时候，如果没有进行初始化，它的值是不确定的（乱指一气）。
            2）如果用指针指向了动态分配的内存，内存被释放后，指针不会置空，但是，指向的地址已失效。
            3）指针指向的变量已超越变量的作用域（变量的内存空间已被系统回收),把指针指向了函数的局部变量，或者把函数的局部变量的地址作为返回值赋给了指针,会发生该情况.
        规避方法：
            1）指针在定义的时候，如果没地方指，就初始化为nullptr。
            2）动态分配的内存被释放后，将其置为nullptr。
            3）函数不要返回局部变量的地址。
            4) 使用智能指针
        注意：野指针的危害比空指针要大很多，在程序中，如果访问野指针，可能会造成程序的崩溃。是可能，不是一定，程序的表现是不稳定，增加了调试程序的难度。
        
    函数指针和回调函数
        函数的二进制代码存放在内存四区中的代码段，函数的地址是它在内存中的起始地址。如果把函数的地址作为参数传递给函数，就可以在函数中灵活的调用其它函数。
        使用函数指针的三个步骤：
            a）声明函数指针；
                声明普通指针时，必须提供指针的类型。同样，声明函数指针时，也必须提供函数类型，函数的类型是指返回值和参数列表（函数名和形参名不是）
                假设函数的原型是：
                    int func1(int bh,string str);
                    int func2(int no,string message);
                    int func3(int id,string info);

                    bool func4(int id,string info);

                    bool func5(int id);
                则函数指针的声明是：
                    int  (*pfa)(int,string);

                    bool (*pfb)(int,string);

                    bool (*pfc)(int);
                pfa、pfb、pfc是函数指针名，必须用括号，否则就成了返回指针的函数。
            b）让函数指针指向函数的地址；
                函数名就是函数的地址。
                函数指针的赋值：函数指针名=函数名;
            c）通过函数指针调用函数。
                c语法:
                    (*函数指针名)(实参);
                cpp语法:
                    函数指针名(实参);

捌.数组(008Array)

    数组的基本概念
        数组是一组数据类型相同的变量，可以存放一组数据。
        创建数组
            语法：数据类型 数组名[数组长度];
            注意：
                数组长度必须是整数，可以是常量，也可以是变量和表达式。
                C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。
                经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        数组的使用
            可以通过下标访问数组中元素，数组下标从0开始。
            语法：数组名[数组下标]
            注意：
                数组下标也必须是整数，可以是常量，也可以是变量。
                合法的数组下标取值是：0~(数组长度-1)。
        数组占用内存的情况
            数组在内存中占用的空间是连续的。
            用sizeof(数组名)可以得到整个数组占用内存空间的大小（只适用于C++基本数据类型）。
        数组的初始化
            声明的时候初始化：
                数据类型 数组名[数组长度] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[ ] = { 值1，值2，值3, ...... , 值n};
                数据类型 数组名[数组长度] = { 0 };  // 把全部的元素初始化为0。
                数据类型 数组名[数组长度] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。
                如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
                C++11标准可以不写等于号。
        清空数组
            用memset()函数可以把数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制数组
            用memcpy()函数可以把数组中全部的元素复制到另一个相同大小的数组。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    数组和指针
        指针的算术
            将一个整型变量加1后，其值将增加1。
            但是，将指针变量（地址的值）加1后，增加的量等于它指向的数据类型的字节数。
        数组的地址
            a）数组在内存中占用的空间是连续的。
            b）C++将数组名解释为数组第0个元素的地址。
            c）数组第0个元素的地址和数组首地址的取值是相同的。
            d）数组第n个元素的地址是：数组首地址+n
            e）C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
        数组的本质
            数组是占用连续空间的一块内存，数组名被解释为数组第0个元素的地址。
            C++操作这块内存有两种方法：数组解释法和指针表示法，它们是等价的。
        数组名不一定会被解释为地址
            在多数情况下，C++将数组名解释为数组的第0个元素的地址，但是，将sizeof运算符用于数据名时，将返回整个数组占用内存空间的字节数,所以数组名并不是的地址.
            可以修改指针的值，但数组名是常量，不可修改。
            
    数组的越界
        数组越界在windows下是会报错且终止程序运行的,但是在linux下所有越界的值都将赋为0.
        数组越界就是一种野指针, 所以开发时需要注意, 这种低级错误不要犯.
            int arr6[5] = {0,1,2,3,4};
            for (int i = 0; i < 8; i++) {
                arr6[i] = i + 100;
                cout << "arr6[ + " << i << "]的值是 = " << (long long)arr6[i] << endl;
            };
    
    数组用于函数的参数
        1）指针的数组表示
            在C++内部，用指针来处理数组。
            1) C++编译器把   数组名[下标]  解释为  *(数组首地址+下标)
            2) C++编译器把   地址[下标]  解释为  *(地址+下标)
        2）一维数组用于函数的参数
            一维数组用于函数的参数时，只能传数组的地址，并且必须把数组长度也传进去，除非数组中有最后一个元素的标志。
            书写方法有两种： 
                void func(int* arr, int len);
                void func(int arr[], int len);
            注意：
                在函数中，可以用数组表示法，也可以用指针表示法。
                在函数中，不要对指针名用sizeof运算符,它不是数组名,
                    因为sizeof(数组名)得到的是数组的内存大小,如func();
                    而sizeof(指针名)得到的永远都是8字节,这就是为什么要把数组长度计算好再传进来的原因了
        
    用new动态创建数组
        普通数组在栈上分配内存，栈很小；如果需要存放更多的元素，必须在堆上分配内存。
        动态创建一维数组的语法：
            数据类型 *指针=new 数据类型[数组长度];
        释放一维数组的语法：
            delete [] 指针;
        注意：
            动态创建的数组没有数组名，不能用sizeof运算符。
            可以用数组表示法和指针表示法两种方式使用动态创建的数组。
            必须使用delete[]来释放动态数组的内存（不能只用delete）。
            不要用delete[]来释放不是new[]分配的内存。
            不要用delete[]释放同一个内存块两次（否则等同于操作野指针）。
            对空指针用delete[]是安全的（释放内存后，应该把指针置空nullptr）。
            声明普通数组的时候，数组长度可以用变量，相当于在栈上动态创建数组，并且不需要释放。
            如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。
            为什么用delete[]释放数组的时候，不需要指定数组的大小？因为系统会自动跟踪已分配数组的内存。
            
    数组排序
        qsort()函数用于对各种数据类型的数组进行排序。
        函数的原型：
            void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
            第一个参数：数组的起始地址(数组名)
            第二个参数：数组元素的个数（数组长度）。
            第三个参数：数组元素的大小（sizeof(数组的数据类型)）。
            第四个参数：回调函数的地址。
            回调函数决定了排序的顺序，声明如下：    
                int compar(const void *p1, const void *p2);
                1）如果函数的返回值< 0 ，那么p1所指向元素会被排在p2所指向元素的前面。
                2）如果函数的返回值==0，那么p1所指向元素与p2所指向元素的顺序不确定。
                3）如果函数的返回值> 0 ，那么p1所指向元素会被排在p2所指向元素的后面。
                
                void qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));
        qsort()函数的其它细节：
            形参中的地址用void是为了支持任意数据类型，在回调函数中必须具体化。
            为什么需要第三个形参size_t size？
            size_t是C标准库中定义的，在64位系统中是8字节无符号整型（unsigned long long）typedef unsigned long long size_t
            排序的需求除了升序和降序，还有很多不可预知的情况，只能用回调函数。
        
    数组查找
        折半查找也叫二分查找，只适用于已排序的数组（升序降序都可以）。
        
    C字符串
        cpp中的string使用方便,能自动扩展,无需担心内存问题,string是cpp的类,是对C中字符串的封装
        但在某些应用场景中,C字符串更方便和高效.
        C语言约定：如果字符型（char）数组的末尾包含了空字符\0（也就是0），那么该数组中的内容就是一个字符串。
        因为字符串需要用0结尾，所以在声明字符数组的时候，要预留多一个字节用来存放0。
        声明一个最多存放20个英文字符或十个中文的字符串。
            char name[21];
        初始方法:
            char str2[11] = "hello";
            char str3[] = {"hello"};
            char str4[11] = {"hello"};
            char str5[11]{"hello"};
            char str6[11] = {0}
                把全部元素初始化为0,相当于清空字符串的意思
        清空字符串:
            memset(name,0,sizeof(name));
                把全部的元素置为0:
            str[0]=0;
                C约定了用0表示字符串的结束,那么第一个元素置为0,那么后面的任何值都没有意义了(不规范,有隐患,不推荐)
        字符串复制或赋值(strcpy)
            cpp字符串可以字节用等号赋值,但是c字符串不可以,要用strcpy函数实现赋值.
            char *strcpy(char* dest, const char* src);
            参数: 目标字符串,源字符串
            功 能: 将参数src字符串拷贝至参数dest所指的地址。
            返回值: 返回参数dest的字符串起始地址。
            复制完字符串后，会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串复制或赋值(strncpy)
            char * strncpy(char* dest,const char* src, const size_t n);
            功能：把src前n个字符的内容复制到dest中。
            返回值：dest字符串起始地址。
            如果src字符串长度小于n，则拷贝完字符串后，在dest后追加0，直到n个。
            如果src的长度大于等于n，就截取src的前n个字符，不会在dest后追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
            strncpy的坑点:
                strncpy(str8, "hello", 3);
                hello是五个字符,但是只有3个值,windows平台下会将其他值赋为垃圾值.
                解决这个问题就是在strncpy之前,用memset将字符数组清空:memset(str8, 0, sizeof(str8));
        获取字符串的长度(strlen)
            size_t  strlen( const char*  str);
            功能：计算字符串的有效长度，不包含0。
            返回值：返回字符串的字符数。
            strlen()函数计算的是字符串的实际长度，遇到0结束。
        字符串拼接(strcat)
            char *strcat(char* dest,const char* src);
            功能：将src字符串拼接到dest所指的字符串尾部。
            返回值：返回dest字符串起始地址。
            dest最后原有的结尾字符0会被覆盖掉，并在连接后的字符串的尾部再增加一个0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串拼接(strncat)
            char *strncat (char* dest,const char* src, const size_t n);
            功能：将src字符串的前n个字符拼接到dest所指的字符串尾部。
            返回值：返回dest字符串的起始地址。
            如果n大于等于字符串src的长度，那么将src全部追加到dest的尾部，如果n小于字符串src的长度，只追加src的前n个字符。
            strncat会将dest字符串最后的0覆盖掉，字符追加完成后，再追加0。
            如果参数dest所指的内存空间不够大，会导致数组的越界。
        字符串比较strcmp()和strncmp()
            int strcmp(const char *str1, const char *str2 );
            功能：比较str1和str2的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            int strncmp(const char *str1,const char *str2 ,const size_t n);
            功能：比较str1和str2前n个字符的大小。
            返回值：相等返回0，str1大于str2返回1，str1小于str2返回-1；
            两个字符串比较的方法是比较字符的ASCII码的大小，从两个字符串的第一个字符开始，如果分不出大小，就比较第二个字符，如果全部的字符都分不出大小，就返回0，表示两个字符串相等。
            在实际开发中，程序员一般只关心字符串是否相等，不关心哪个字符串更大或更小。
        查找字符strchr()和strrchr()
            const char *strchr(const char *s, int c);
            返回在字符串s中第一次出现c的位置，如果找不到，返回0。
            const char *strrchr(const char *s, int c);
            返回在字符串s中最后一次出现c的位置，如果找不到，返回0。
        查找字符串strstr()
            char *strstr(const char* str,const char* substr);
            功能：检索子串在字符串中首次出现的位置。
            返回值：返回字符串str中第一次出现子串substr的地址；如果没有检索到子串，则返回0。
        用于string的表达式
            可以把C风格的字符串用于包含了string类型的赋值拼接等表达式中。
        注意事项
            a）字符串的结尾标志是0，按照约定，在处理字符串的时候，会从起始位置开始搜索0，一直找下去，找到为止（不会判断数组是否越界）。
            b）结尾标志0后面的都是垃圾内容。
            c）字符串在每次使用前都要初始化，减少入坑的可能，是每次，不是第一次。
            d）不要在子函数中对字符指针用sizeof运算，所以，不能在子函数中对传入的字符串进行初始化，除非字符串的长度也作为参数传入到了子函数中。
            e）windoes平台中，默认C标准的字符串操作函数是不安全的，如果要使用C标准的字符串操作函数，要在源代码文件的最上面加 #define _CRT_SECURE_NO_WARNINGS，还可以通过 strcpy_s，strcat_s ... 等函数处理字符串函数操作的安全性问题,一般在linux平台下是不会有这些问题的,所以了解下即可.
    
    二维数组
        一维数组的数学概念是线性表，二维数组的数学概念是矩阵。
        创建二维数组
            声明二维数组的语法：数据类型 数组名[行数][列数];
            注意：数组长度必须是整数，可以是常量，也可以是变量和表达式。
            C90规定必须用常量表达式指明数组的大小，C99允许使用整型非常量表达式。经测试，在VS中可以用用整型非常量表达式，不能用变量；但是，Linux中还可以用变量。
        二维数组的使用
            可以通过行下标和列下标访问二维数组中元素，下标从0开始。
            二维数组中每个元素的特征和使用方法与单个变量完全相同。
            语法：数组名[行下标][列下标]
            注意：
            二维数组下标也必须是整数，可以是常量，也可以是变量。
            合法的行下标取值是：0~(行数-1)。
            合法的列下标取值是：0~(列数-1)。
        二维数组占用内存的情况
            用sizeof(数组名)可以得到整个二维数组占用内存空间的大小（只适用于C++基本数据类型）。
            二维数组在内存中占用的空间是连续的。
            二维数组的数组名也被解释为起始地址,和一维数组是一样的,用一维数组的方法可以正常显示而为数组的内容
        二维数组的初始化
            声明的时候初始化：
            数据类型 数组名[行数][列数] = { {数据1，数据2 } ，{数据3，数据4 },...... };
            数据类型 数组名[行数][列数] = { 数据1，数据2，数据3，数据4, ......};
            数据类型 数组名[ ][列数] = { 数据1，数据2，数据3，数据4,......};
            数据类型 数组名[行数][列数] = { 0 };  // 把全部的元素初始化为0。
            数据类型 数组名[行数][列数] = { };    // 把全部的元素初始化为0。
            注意：
                如果{}内不足数组长度个数据，剩余数据用0补全，但是，不建议这么用，你可能在数组中漏了某个值。如果想把数组中全部的元素初始化为0，可以在{}内只填一个0或什么也不填。
            C++11标准可以不写等于号。
        清空二维数组
            用memset()函数可以把二维数组中全部的元素清零。（只适用于C++基本数据类型）
            函数原型：void *memset(void *s, int c, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
        复制二维数组
            用memcpy()函数可以把二维数组中全部的元素复制到另一个相同大小的数组（没说多少维）。（只适用于C++基本数据类型）
            函数原型：void *memcpy(void *dest, const void *src, size_t n);
            注意，在Linux下，使用memcpy()函数需要包含头文件#include <string.h>
    
    二维数组用于函数的参数
        指针复习:
            整型指针。
                int* p;
            一维整型指针数组，元素是3个整型指针（p[0]、p[1]、p[2]）。   
                int* p[3];
            函数p的返回值类型是整型的地址。
                int* p(); 
            p是函数指针，函数的返回值是整型。
                int (*p)(int ,int);
        概念:
            地址是地址,指针是指针,不要把地址说成指针,指针是一个容器,是用于存放地址的.
        行指针(数组指针):
            声明行指针的语法：数据类型 (*行指针名)[行的大小];  // 行的大小即数组长度。
            int (*p1)[3];  // p1是行指针，用于指向数组长度为3的int型数组。
            int (*p2)[5];  // p2行指针，用于指向数组长度为5的int型数组。
            double (*p3)[5];  // p3是行指针，用于指向数组长度为5的double型数组。
            一维数组名被解释为数组第0个元素的地址。
            对一维数组名取地址得到的是数组的地址，是行地址。
        二维数组名是行地址
            int bh[2][3] = { {11,12,13},{21,22,23} };
            bh是二维数组名，该数组有2两元素，每一个元素本身又是一个数组长度为3的整型数组。
            bh被解释为数组长度为3的整型数组类型的行地址。
            如果存放bh的值，要用数组长度为3的整型数组类型的行指针。
            int (*p)[3]=bh;

        把二维数组传递给函数
            如果要把bh传给函数，函数的声明如下：
            void func(int (*p)[3],int len);
            void func(int p[][3],int len);
        
    多维数组
        int bh[4][2][3];
        bh是三维数组名，该数组有4元素，每一个元素本身又是一个2行3列的二维数组。
        bh被解释为2行3列的二维数组类型的二维地址。
        如果存放bh的值，要用2行3列的二维数组类型的二维指针。
        int (*p)[2][3]=bh;

玖.结构体(009StructureAndEnumeration)

    结构体的基本概念(basic-concepts.cpp)
        结构体是用户自定义的类型，可以将多种数据的表示合并到一起，描述一个完整的对象。
        使用结构体有两个步骤：
            1）定义结构体描述（类型）
            2）创建结构体变量
        定义结构体描述
            语法:
                struct 结构体名 {
                    成员一的数据类型  成员名一;
                    成员二的数据类型  成员名二;
                    成员三的数据类型  成员名三;
                    ......
                    成员n的数据类型  成员名n;
                };
            注意：
                结构体名是标识符。
                结构体的成员可以是任意数据类型。
                定义结构体描述的代码可以放在程序的任何地方，一般放在main函数的上面或头文件中。
                结构体成员可以用C++的类（如string），但是不提倡。
                在C++中，结构体中可以有函数，但是不提倡。
                在C++11中，定义结构体的时候可以指定缺省值。
        创建结构体变量
            创建结构体变量的语法：
                struct 结构体名 结构体变量名;
            也可以为结构体成员赋初始值。
                struct 结构体名 结构体变量名={成员一的值, 成员二的值,......, 成员n的值};
            C++11可以不写等于号。
            如果大括号内未包含任何东西或只写一个0，全部的成员都将被设置为0。
                struct 结构体名 结构体变量名={0};
            注意：
                在C++中，struct关键字可以不写。
                可以在定义结构体的时候创建结构体变量。
        使用结构体
            在C++程序中，用成员运算符（.）来访问结构体的每个成员。结构体中的每个成员具备普通变量的全部特征。
            语法：结构体变量名.结构体成员名;
        占用内存的大小
            用sizeof运算符可以得到整个结构体占用内存的大小。
            注意：整个结构体占用内存的大小不一定等于全部成员占用内存之和。
            内存对齐：#pragma pack(字节数)
            合理使用内存对齐规则，某些节省内存的做法可能毫无意义。
        清空结构体
            创建的结构体变量如果没有初始化，成员中有垃圾值。
            用memset()函数可以把结构体中全部的成员清零。（只适用于C++基本数据类型）
            bzero()函数也可以。
        复制结构体
            用memcpy()函数把结构体中全部的元素复制到另一个相同类型的结构体（只适用于C++基本数据类型）。
            也可以直接用等于号（只适用于C++基本数据类型）。
        
    结构体指针(structure-pointer.cpp)
        结构体是一种自定义的数据类型，用结构体可以创建结构体变量。
        基本语法
            在C++中，用不同类型的指针存放不同类型变量的地址，这一规则也适用于结构体。如下：
                struct st_girl girl;         // 声明结构体变量girl。
                struct st_girl *pst=&girl;  // 声明结构体指针，指向结构体变量girls。
            通过结构体指针访问结构体成员，有两种方法：
                (*指针名).成员变量名    // (*pst).name和(*pst).age 
            或者：
                指针名->成员变量名    // pst->name和*pst->age 
            在第一种方法中，圆点.的优先级高于*，(*指针名)两边的括号不能少。如果去掉括号写成(*指针名).成员变量名，那么相当于*(指针名.成员变量名)，意义就完全不一样了。
            在第二种方法中，->是一个新的运算符。
            上面的两种方法是等效的，程序员通常采用第二种方法，更直观。
            注意：与数组不一样，结构体变量名没有被解释为地址。
        用于函数的参数
            如果要把结构体传递给函数，实参取结构体变量的地址，函数的形参用结构体指针。
            如果不希望在函数中修改结构体变量的值，可以对形参加const约束。
        用于动态分配内存
            用结构体指针指向动态分配的内存的地址。
    
    结构体数组(structure-array.cpp)
        结构体可以被定义成数组变量，本质上与其它类型的数组变量没有区别。
        声明结构体数组的语法：struct 结构体类型 数组名[数组长度];
        初始化结构体数组，要结合使用初始化数组的规则和初始化结构体的规则。
            struct st_girl girls[2]={{"西施",26,43.8,'X',true},{"西瓜",25,52.8,'X',false}};
        使用结构体数组可以用数组表示法，也可以用指针表示法。
        在结构体中嵌入数组和结构体
            super_girl3 sg3 = {"hillary", 36,45,'X',true,{"Ethan","dog"}};
        
    结构体中的指针(basic-concepts.cpp)
        如果结构体中的指针指向的是动态分配的内存地址：
            对结构体用sizeof运算可能没有意义。
            对结构体用memset()函数可能会造成内存泄露。
        C++的字符串string中有一个指针，指向了动态分配内存的地址。
            struct string
            {
                char *ptr;   // 指向动态分配内存的地址。
                ......
            }
        结论:
            在没有动态分配内存之前,是可以用memset清空结构体的
            在动态分配内存之后,就不能用memset清空结构体了,只能逐个成员进行清空处理.
            总之,清空结构体最好是逐个成员都进行清空.
    
    简单链表(linked-list.cpp)
        如果结构体中有一个本结构体的指针，它就是链表。
        最传统写法
            tmp = new st_girl;
            tmp -> no = 1;
            tmp -> name = "西施";
            tmp -> next = nullptr;
        c11标准写法
            tmp = new st_girl;
            *(tmp) = {1,"西施",nullptr};
        在new时指定节点初始值
            tmp = new st_girl({1,"西施",nullptr});
        注意:
            新分配的节点next指针一般为空,如果需要指向哪个节点在之后赋予其.
        链表是数据结构课程中的重点,但本章节的目标是cpp,不是数据结构,所以点到即止,为链表有初步的认识即可.
        
    共同体(union.cpp)
        共同体能够存储不同的数据类型，但是，在同一时间只能存储其中的一种类型。
        注意：
            共同体占用内存的大小是它最大的成员占用内存的大小（内存对齐）。
            全部的成员使用同一块内存。
            共同体中的值为最后被赋值的那个成员的值。
            匿名共同体没有名字，可以在定义的时候创建匿名共同体变量，也可以嵌入结构体中。
        共同体常用于节省内存的场景（嵌入式系统）。
        
    枚举(enumeration.cpp)
        之前章节学习过创建常量的两种方法(宏常量和const常量),枚举也是一种创建符号常量的方法。
        枚举的语法：
            enum 枚举名 { 枚举量1 , 枚举量2 , 枚举量3, ......, 枚举量n };
        例如：
            enum colors { red , yellow , blue };
        这条语句完成了两项工作：
            让colors成了一种新的枚举类型的名称，可以用它创建枚举变量。
            将red、yellow、blue作为符号常量，默认值是整数的0、1、2。
        注意：
            用枚举创建的变量取值只能在枚举量范围之内。
            枚举的作用域与变量的作用域相同。
            可以显式的设置枚举量的值（必须是整数）,默认是 {red=0, yellow=1, blue=2}
                enum colors {red=1,yellow=2,blue=3};
            可以只显式的指定某些枚举量的值（枚举量的值可以重复）。
                enum colors {red=10,yellow,blue};
            可以将整数强制转换成枚举量，语法：枚举类型(整数)

拾.引用(010Reference)

    引用的基本概念(basic-concepts.cpp)
        引用变量是C++新增的复合类型,c语言中没有.
        引用是已定义的变量的别名。
        引用的主要用途是用作函数的形参和返回值。
        声明/创建引用的语法：数据类型 &引用名=原变量名;
        注意：
            引用的数据类型要与原变量名的数据类型相同。
            引用名和原变量名可以互换，它们值和内存单元是相同的。
            必须在声明引用的时候初始化，初始化后不可改变。
            C和C++用&符号来指示/取变量的地址，C++给&符号赋予了另一种含义。
        引用的本质
            引用是指针常量的伪装。
            引用是编译器提供的一个有用且安全的工具，去除了指针的一些缺点，禁止了部分不安全的操作。

            变量是什么？变量就是一个在程序执行过程中可以改变的量。
            换一个角度，变量是一块内存区域的名字，它代表了这块内存区域，当我们对变量进行修改的时候，会引起内存区域中内容的改变。
            在计算机看来，内存区域根本就不存在什么名字，它仅有的标志就是它的地址，因此我们若想修改一块内存区域的内容，只有知道他的地址才能实现。
            所谓的变量只不过是编译器给我们进行的一种抽象，让我们不必去了解更多的细节，降低我们的思维跨度而已。
            程序员拥有引用，但编译器仅拥有指针（地址）。
            引用的底层机制实际上是和指针一样的。不要相信有别名，不要认为引用可以节省一个指针的空间，因为这一切不会发生，编译器还是会把引用解释为指针。
            引用和指针本质上没有区别。
        引用用于函数的参数
            把函数的形参声明为引用，调用函数的时候，形参将成为实参的别名。
            这种方法也叫按引用传递或传引用。（传值、传地址、传引用只是说法不同，其实都是传值。）
            引用的本质是指针，传递的是变量的地址，在函数中，修改形参会影响实参。
                1）传引用的代码更简洁。
                2）传引用不必使用二级指针。
                3）引用的属性和特别之处。
            二级指针的传递改用引用传递
        引用的形参和const
            如果引用的数据对象类型不匹配，当引用为const时，C++将创建临时变量，让引用指向临时变量。
            什么时候将创建临时变量呢？
                引用是const。
                数据对象的类型是正确的，但不是左值。
                数据对象的类型不正确，但可以转换为正确的类型。
            结论：如果函数的实参不是左值或与const引用形参的类型不匹配，那么C++将创建正确类型的匿名变量，将实参的值传递给匿名变量，并让形参来引用该变量。
            将引用形参声明为const的理由有三个：
                使用const可以避免无意中修改数据的编程错误。
                使用const使函数能够处理const和非const实参，否则将只能接受非const实参。
                使用const，函数能正确生成并使用临时变量。
            左值是可以被引用的数据对象，可以通过地址访问它们，例如：变量、数组元素、结构体成员、引用和解引用的指针。
            非左值包括字面常量（用双引号包含的字符串除外）和包含多项的表达式。
            总之左值就是可以出现在赋值语句 = 左边的量或值,非左值就是赋值语句 = 右边的量或值.
            如下:
                int& a = 8;
                这个语法是报错的, 因为引用a的值必须是变量,不能是一个常量.
                const int& a = 8;
                但是将它声明为const就可以,是因为C++将创建临时变量，让常量引用指向临时变量,即:
                int tmp = 8;
                const int& a = tmp;
            自结论:
                作为函数参数,如果是传值的方法,实参可以是常量也可以是变量
                如果是传地址或传引用,实参就一定要用变量.

    引用用于函数的返回值(function-return-reference.cpp)
        传统的函数返回机制与值传递类似。
        函数的返回值被拷贝到一个临时位置（寄存器或栈），然后调用者程序再使用这个值。
            double m = sqrt(36);      // sqrt()是求平方根函数。
        sqrt(36)的返回值6被拷贝到临时的位置，然后赋值给m。
            cout << sqrt(25);
        sqrt(25)的返回值5被拷贝到临时的位置，然后传递给cout。
        如果返回的是一个结构体，将把整个结构体拷贝到临时的位置。
        如果返回引用不会拷贝内存。
        语法：
            返回值的数据类型& 函数名(形参列表);
        注意：
            如果返回局部变量的引用，其本质是野指针，后果不可预知。
            可以返回函数的引用形参、类的成员、全局变量、静态变量。
            返回引用的函数是被引用的变量的别名，将const用于引用的返回类型。
        各种形参的使用场景
            传值、传地址和传引用的指导原则《C++ Primer Plus》
            1）如果不需要在函数中修改实参
                如果实参很小，如C++内置的数据类型或小型结构体，则按值传递。
                如果实参是数组，则使用const指针，因为这是唯一的选择（没有为数组建立引用的说法）。
                如果实参是较大的结构，则使用const指针或const引用。
                如果实参是类，则使用const引用，传递类的标准方式是按引用传递（类设计的语义经常要求使用引用）。
            2）如果需要在函数中修改实参
                如果实参是内置数据类型，则使用指针。只要看到func(&x)的调用，表示函数将修改x。
                如果实参是数组，则只能使用指针。
                如果实参是结构体，则使用指针或引用。
                如果实参是类，则使用引用。
                当然，这只是一些指导原则，很可能有充分的理由做出其他的选择。
                例如：对于基本类型，cin使用引用，因此可以使用cin>>a，而不是cin>>&a。
        函数的默认参数:
            默认参数是指调用函数的时候，如果不书写实参，那么将使用的一个缺省值。
            语法：
                返回值 函数名(数据类型 参数=值, 数据类型 参数=值,……);
            注意：
                如果函数的声明和定义是分开书写的，在函数声明中书写默认参数，函数的定义中不能书写默认参数。
                函数必须从右到左设置默认参数。也就是说，如果要为某个参数设置默认值，则必须为它后面所有的参数设置默认值。
                调用函数的时候，如果指定了某个参数的值，那么该参数前面所有的参数都必须指定。
        函数重载
            函数重载（函数多态）是指设计一系列同名函数，让它们完成相同（似）的工作。
            C++允许定义名称相同的函数，条件是它们的特征（形参的个数、数据类型和排列顺序）不同。
                #1    int func(short a  ,string b);
                #2    int func(int a    ,string b);
                #3    int func(double a,string b);
                #4    int func(int a    ,string b, int len);
                #5    int func(string b , int a);
            调用重载函数的时候，在代码中我们用相同的函数名，但是，后面的实参不一样，编译器根据实参与重载函数的形参进行匹配，然后决定调用具体的函数，如果匹配失败，编译器将视为错误。
            在实际开发中，视需求重载各种数据类型，不要重载功能不同的函数。
            注意：
                使用重载函数时，如果数据类型不匹配，C++尝试使用类型转换与形参进行匹配，如果转换后有多个函数能匹配上，编译将报错。
                引用可以作为函数重载的条件，但是，调用重载函数的时候，如果实参是变量，编译器将形参类型的本身和类型引用视为同一特征。
                如果重载函数有默认参数，调用函数时，可能导致匹配失败。
                const不能作为函数重载的特征。
                返回值的数据类型不同不能作为函数重载的特征。
                C++的名称修饰：编译时，对每个函数名进行加密，替换成不同名的函数。
                    void MyFunctionFoo(int,float);
                    void MyFunctionFoo(long,float);
                    ?MyFunctionFoo@@YAXH(int,float);
                    #void MyFunctionFoo^$@(long,float);
        内联函数
            C++将内联函数的代码组合到程序中，可以提高程序运行的速度。
            语法：在函数声明和定义前加上关键字inline。
            通常的做法是将函数声明和定义写在一起。
            注意：
                内联函数节省时间，但消耗内存。
                如果函数过大，编译器可能不将其作为内联函数。
                内联函数不能递归。
            自结论:
                内联函数一般在较少代码块或测试时应用.

拾壹.课程巩固(011CourseConsolidation)

    第一章节(chapter_one)
    第二章节(chapter_two)
    第三章节(chapter_three)
    第四章节(chapter_four)
    第五章节(chapter_five)
        总共以上五个章节,详见视频:
            https://ke.qq.com/webcourse/index.html?r=1693747928895#cid=5855339&term_id=106263629&taid=14191199017064555&type=3072&source=PC_COURSE_DETAIL&vid=387702307788503566
        详见章节:
            课后作业(一)
            课后作业(二)
            课后作业(三)
            课后作业(四)
            课后作业(五)

拾贰.类(012Class)

    类基础(class_basic)
        从结构体到类
            对面向对象编程来说，一切都是对象，对象用类来描述。
            类把对象的数据和操作数据的方法作为一个整体考虑。
            定义类的语法：
                class 类名
                {
                    public:
                    成员一的数据类型  成员名一;
                    成员二的数据类型  成员名二;
                    成员三的数据类型  成员名三;
                    ......
                    成员n的数据类型  成员名n;
                };
            注意：
                类的成员可以是变量，也可以是函数。
                类的成员变量也叫属性。
                类的成员函数也叫方法/行为，类的成员函数可以定义在类的外面。
                用类定义一个类的变量叫创建（或实例化）一个对象。
                对象的成员变量和成员函数的作用域和生命周期与对象的作用域和生命周期相同。
        类的访问权限
            类的成员有三种访问权限：public、private和protected，分别表示公有的、私有的和受保护的。
            在类的内部（类的成员函数中），无论成员被声明为 public还是private，都可以访问。
            在类的外部（定义类的代码之外），只能访问public成员，不能访问private、protected成员。
            在一个类体的定义中，private 和 public 可以出现多次。
            结构体的成员缺省为public，类的成员缺省为private。
            private的意义在于隐藏类的数据和实现，把需要向外暴露的成员声明为public。
        简单使用类
            1）类的成员函数可以直接访问该类其它的成员函数（可以递归）。
            2）类的成员函数可以重载，可以使用默认参数。
            3）类指针的用法与结构体指针用法相同。
            4）类的成员可以是任意数据类型（类中枚举）。
            5）可以为类的成员指定缺省值（C++11标准）。
            6）类可以创建对象数组，就像结构体数组一样。
            7）对象可以作为实参传递给函数，一般传引用。
            8）可以用new动态创建对象，用delete释放对象。
            9）在类的外部，一般不直接访问（读和写）对象的成员，而是用成员函数。数据隐藏是面向对象编程的思想之一。
            10）对象一般不用memset()清空成员变量，可以写一个专用于清空成员变量的成员函数。
            11）对类和对象用sizeof运算意义不大，一般不用。
            12）用结构体描述纯粹的数据，用类描述对象。
            13）在类的声明中定义的函数都将自动成为内联函数;在类的声明之外定义的函数如果使用了inline限定符,也是内联函数
            14）为了区分类的成员变量和成员函数的形参，把成员变量名加m_前缀或_后缀，如m_name或name_。
            15）类的分文件编写。
    
    构造函数(constructor_func)
        构造函数：在创建对象时，自动的进行初始化工作。
        析构函数：在销毁对象前，自动的完成清理工作。
        1）构造函数
            语法：类名(){......}
                访问权限必须是public。
                函数名必须与类名相同。
                没有返回值，不写void。
                可以有参数，可以重载，可以有默认参数。
                创建对象时只会自动调用一次，不能手工调用。
        2）析构函数
            语法：~类名(){......}
                访问权限必须是public。
                函数名必须在类名前加~。
                没有返回值，也不写void。
                没有参数，不能重载。
                销毁对象前只会自动调用一次，但是可以手工调用。
        注意：
            如果没有提供构造/析构函数，编译器将提供空实现的构造/析构函数。
            如果提供了构造/析构函数，编译器将不提供空实现的构造/析构函数。
            创建对象的时候，如果重载了构造函数，编译器根据实参匹配相应的构造函数。没有参数的构造函数也叫默认构造函数。
            创建对象的时候不要在对象名后面加空的圆括号，编译器误认为是声明函数。（如果没有构造函数、构造函数没有参数、构造函数的参数都有默认参数）
            在构造函数名后面加括号和参数不是调用构造函数，是创建匿名对象。
            接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值（可能会导致问题，不推荐）。
                CGirl girl =10;
            以下两行代码有本质的区别：
                CGirl girl = CGirl("西施"20);  // 显式创建对象。
                CGirl girl;                   // 创建对象。
                girl = CGirl("西施"20);        // 创建匿名对象，然后给现有的对象赋值。
            用new/delete创建/销毁对象时，也会调用构造/析构函数。
            不建议在构造/析构函数中写太多的代码，可以调用成员函数。
            除了初始化，不建议让构造函数做太多工作（只能成功不会失败）。
            C++11支持使用统一初始化列表。
                CGirl girl = {"西施"20};
                CGirl girl  {"西施"20};
                CGirl* girl = new CGirl{ "西施"20 };
            如果类的成员也是类，创建对象的时候，先构造成员类；销毁对象的时候，先析构成员类。
    
    拷贝构造函数(copy_constructor)
        用一个已存在的对象创建新的对象，不会调用（普通）构造函数，而是调用拷贝构造函数。
        如果类中没有定义拷贝构造函数，编译器将提供一个默认的拷贝构造函数，它的功能是把已存在对象的成员变量赋值给新对象的成员变量。
        用一个已存在的对象创建新的对象语法：
            类名 新对象名(已存在的对象名);
            类名 新对象名=已存在的对象名;
            拷贝构造函数的语法：
                类名(const 类名& 对象名){......}
        注意：
            访问权限必须是public。
            函数名必须与类名相同。
            没有返回值，不写void。
            如果类中定义了拷贝构造函数，编译器将不提供默认的拷贝构造函数。
            以值传递的方式调用函数时，如果实参为对象，会调用拷贝构造函数。
            函数以值的方式返回对象时，可能会调用拷贝构造函数（VS会调用，Linux不会，g++编译器做了优化）。
            拷贝构造函数可以重载，可以有默认参数。
                类名(......,const 类名& 对象名,......){......}
            如果类中重载了拷贝构造函数却没有定义默认的拷贝构造函数，编译器也会提供默认的拷贝构造函数。
    
    初始化列表(initializer_cuslist)
        构造函数的执行可以分成两个阶段：初始化阶段和计算阶段（初始化阶段先于计算阶段）。
            初始化阶段：全部的成员都会在初始化阶段初始化。
            计算阶段：一般是指用于执行构造函数体内的赋值操作。
        构造函数除了参数列表和函数体之外，还可以有初始化列表。
        初始化列表的语法：
            类名(形参列表):成员一(值一), 成员二(值二),..., 成员n(值n)
            {......}
        注意：
            1）如果成员已经在初始化列表中，则不应该在构造函数中再次赋值。
            2）初始化列表的括号中可以是具体的值，也可以是构造函数的形参名，还可以是表达式。
            3）初始化列表与赋值有本质的区别，如果成员是类，使用初始化列表调用的是成员类的拷贝构造函数，而赋值则是先创建成员类的对象（将调用成员类的普通构造函数），然后再赋值。
            4）如果成员是类，初始化列表对性能略有提升。
            5）如果成员是常量和引用，必须使用初始列表，因为常量和引用只能在定义的时候初始化。
            6）如果成员是没有默认构造函数的类，则必须使用初始化列表。
            7）拷贝构造函数也可以有初始化列表。
            8）类的成员变量可以不出现在初始化列表中。
            9）构造函数的形参先于成员变量初始化。
    
    const修饰成员函数(const_decorate_func)
        在类的成员函数后面加const关键字，表示在成员函数中保证不会修改调用对象的成员变量。
        注意：
            1）mutable可以突破const的限制，被mutable修饰的成员变量，将永远处于可变的状态，在const修饰的函数中，mutable成员也可以被修改。
            2）非const成员函数可以调用const成员函数和非const成员函数。
            3）const成员函数不能调用非const成员函数。
            4）非const对象可以调用const修饰的成员函数和非const修饰的成员函数。
            5）const对象只能调用const修饰的成员函数，不能调用非cosnt修饰的成员函数。
        
        这里出现了令人纠结的三个问题：
            1、为什么要保护类的成员变量不被修改？
            2、为什么用const保护了成员变量，还要再定义一个mutable关键字来突破const的封锁线？
            3、到底有没有必要使用const和mutable这两个关键字？
        原因：
            保护类的成员变量不在成员函数中被修改，是为了保证模型的逻辑正确，通过用const关键字来避免在函数中错误的修改了类对象的状态。
            并且在所有使用该成员函数的地方都可以更准确的预测到使用该成员函数的带来的影响。
            而mutable则是为了能突破const的封锁线，让类的一些次要的或者是辅助性的成员变量随时可以被更改。
            没有使用const和mutable关键字当然没有错，const和mutable 关键字只是给了建模工具更多的设计约束和设计灵活性，而且程序员也可以把更多的逻辑检查问题交给编译器和建模工具去做，从而减轻程序员的负担。
        
    this指针(this_point)
        如果类的成员函数中涉及多个对象，在这种情况下需要使用this指针。
        this指针存放了对象的地址，它被作为隐藏参数传递给了成员函数，指向调用成员函数的对象（调用者对象）。
        每个成员函数（包括构造函数和析构函数）都有一个this指针，可以用它访问调用者对象的成员。（可以解决成员变量名与函数形参名相同的问题）
        *this可以表示对象。
        如果在成员函数的括号后面使用const，那么将不能通过this指针修改成员变量。
        
    静态成员(static_member)
        类的静态成员包括静态成员变量和静态成员函数。
        用静态成员可以变量实现多个对象之间的数据共享，比全局变量更安全性。
        用static关键字把类的成员变量声明为静态，表示它在程序中（不仅是对象）是共享的。
        静态成员变量不会在创建对象的时候初始化，必须在程序的全局区用代码清晰的初始化（用范围解析运算符::）。
        静态成员使用类名加范围解析运算符::就可以访问，不需要创建对象。
        如果把类的成员声明为静态的，就可以把它与类的对象独立开来（静态成员不属于对象）。
        静态成员变量在程序中只有一份（生命周期与程序运行期相同，存放在静态存储区的），不论是否创建了类的对象，也不论创建了多少个类的对象。
        在静态成员函数中，只能访问静态成员，不能访问非静态成员。
        静态成员函数中没有this指针。
        在非静态成员函数中，可以访问静态成员。
        私有静态成员在类外无法访问。
        const静态成员变量可以在定义类的时候初始化。
    
    简单对象模型(simple_object_model)
        在C语言中，数据和处理数据的操作（函数）是分开的。也就是说，C语言本身没有支持数据和函数之间的关联性。
        C++用类描述抽象数据类型（abstract data type，ADT），在类中定义了数据和函数，把数据和函数关联起来。
        对象中维护了多个指针表，表中放了成员与地址的对应关系。
        C++类中有两种数据成员：nonstatic、static，三种函数成员：nonstatic、static、virtual。
            对象内存的大小包括：
                1）所有非静态数据成员的大小；
                2）由内存对齐而填补的内存大小；
                3）为了支持virtual成员而产生的额外负担。
            静态成员变量属于类，不计算在对象的大小之内。
            成员函数是分开存储的，不论对象是否存在都占用存储空间，在内存中只有一个副本，也不计算在对象大小之内。
            用空指针可以调用没有用到this指针的非静态成员函数。
            对象的地址是第一个非静态成员变量的地址，如果类中没有非静态成员变量，编译器会隐含的增加一个1字节的占位成员。
    
    友元(friend_basic)
        如果要访问类的私有成员变量，调用类的公有成员函数是唯一的办法，而类的私有成员函数则无法访问。
        友元提供了另一访问类的私有成员的方案。友元有三种：
            1）友元全局函数
                在友元全局函数中，可以访问另一个类的所有成员。
            2）友元类
                在友元类所有成员函数中，都可以访问另一个类的所有成员。
                友元类的注意事项：
                    友元关系不能被继承。
                    友元关系是单向的，不具备交换性。
                    若类B是类A的友元，类A不一定是类B的友元。B是类A的友元，类C是B的友元，类C不一定是类A的友元，要看类中是否有相应的声明。
            3）友元成员函数(这个有点麻烦，代码实例中没有演示)
                在友元成员函数中，可以访问另一个类的所有成员。
                    声明和定义的顺序如下：
                        class CGirl;            // 前置声明。   
                        class CBoy { ...... };      // CBoy的定义。
                        class CGirl { ...... };      // CGirl的定义。
                        // 友元成员函数的定义。               
                        void CBoy::func(CGirl &g) { ...... }








拾叁.运算符重载(013Operator)

    运算符重载基础(operator_basic)
        C++将运算符重载扩展到自定义的数据类型，它可以让对象操作更美观。
        例如字符串string用加号（+）拼接、cout用两个左尖括号（<<）输出。
        运算符重载函数的语法：
            返回值 operator运算符(参数列表);
        运算符重载函数的返回值类型要与运算符本身的含义一致。
        非成员函数版本的重载运算符函数：形参个数与运算符的操作数个数相同；
        成员函数版本的重载运算符函数：形参个数比运算符的操作数个数少一个，其中的一个操作数隐式传递了调用对象。
        如果同时重载了非成员函数和成员函数版本，会出现二义性。
        注意：
            1）返回自定义数据类型的引用可以让多个运算符表达式串联起来。（不要返回局部变量的引用）
            2）重载函数参数列表中的顺序决定了操作数的位置。
            3）重载函数的参数列表中至少有一个是用户自定义的类型，防止程序员为内置数据类型重载运算符。
            4）如果运算符重载既可以是成员函数也可以是全局函数，应该优先考虑成员函数，这样更符合运算符重载的初衷。
            5）重载函数不能违背运算符原来的含义和优先级。
            6）不能创建新的运算符。
            7）以下运算符不可重载：
                sizeof              sizeof运算符
                .                   成员运算符
                .*                  成员指针运算符
                ::                  作用域解析运算符
                ?:                  条件运算符
                typeid              一个RTTI运算符
                const_cast          强制类型转换运算符
                dynamic_cast        强制类型转换运算符
                reinterpret_cast    强制类型转换运算符
                static_cast         强制类型转换运算符
            8）以下运算符只能通过成员函数进行重载：
                =                   赋值运算符
                ()                  函数调用运算符
                []                  下标运算符
                ->                  通过指针访问类成员的运算符

    重载关系运算符(overloading_relational_operators)
        重载关系运算符（==、!=、>、>=、<、<=）用于比较两个自定义数据类型的大小。
        可以使用非成员函数和成员函数两种版本，建议采用成员函数版本。
    
    重载左移运算符(overloading_left_shift_operators)
        重载左移运算符（<<）用于输出自定义对象的成员变量，在实际开发中很有价值（调试和日志）。
        只能使用非成员函数版本。
        如果要输出对象的私有成员，可以配合友元一起使用。

    重载下标运算符(overloading_subscript_operators)
        如果对象中有数组，重载下标运算符[]，操作对象中的数组将像操作普通数组一样方便。
        下标运算符必须以成员函数的形式进行重载。
        下标运算符重载函数的语法：
            返回值类型 &perator[](参数);
            或者：
            const 返回值类型 &operator[](参数) const;
        使用第一种声明方式，[]不仅可以访问数组元素，还可以修改数组元素。
        使用第二种声明方式，[]只能访问而不能修改数组元素。
        在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应const对象，因为通过const 对象只能调用const成员函数，如果不提供第二种形式，那么将无法访问const对象的任何数组元素。
        在重载函数中，可以对下标做合法性检查，防止数组越界。


    重载赋值运算符(overloading_assignment_operators)
        C++编译器可能会给类添加四个函数：
            默认构造函数，空实现。
            默认析构函数，空实现。
            默认拷贝构造函数，对成员变量进行浅拷贝。
            默认赋值函数, 对成员变量进行浅拷贝。
        对象的赋值运算是用一个已经存在的对象，给另一个已经存在的对象赋值。
        如果类的定义中没有重载赋值函数，编译器就会提供一个默认赋值函数。
        如果类中重载了赋值函数，编译器将不提供默认赋值函数。
        重载赋值函数的语法：类名 & operator=(const 类名 & 源对象);
        注意：
            编译器提供的默认赋值函数，是浅拷贝。
            如果对象中不存在堆区内存空间，默认赋值函数可以满足需求，否则需要深拷贝。
            赋值运算和拷贝构造不同：拷贝构造是指原来的对象不存在，用已存在的对象进行构造；赋值运算是指已经存在了两个对象，把其中一个对象的成员变量的值赋给另一个对象的成员变量。
    
    重载new和delete运算符(overloading_new_del_operators)
        重载new和delete运算符的目是为了自定义内存分配的细节。（内存池：快速分配和归还，无碎片）
        建议先学习C语言的内存管理函数malloc()和free()。
        在C++中，使用new时，编译器做了两件事情：
            1）调用标准库函数operator new()分配内存；
            2）调用构造函数初始化内存；
        使用delete时，也做了两件事情：
            1）调用析构函数；
            2）调用标准库函数operator delete()释放内存。
        构造函数和析构函数由编译器调用，我们无法控制，但是，可以重载内存分配函数operator new()和释放函数operator delete()。
            1）重载内存分配函数的语法：void* operator new(size_t size);   
            参数必须是size_t，返回值必须是void*。
            2）重载内存释放函数的语法：void operator delete(void* ptr)   
            参数必须是void *（指向由operator new()分配的内存），返回值必须是void。
            
        重载的new和delete可以是全局函数，也可以是类的成员函数。
        为一个类重载new和delete时，尽管不必显式地使用static，但实际上仍在创建static成员函数。
        编译器看到使用new创建自定义的类的对象时，它选择成员版本的operator new()而不是全局版本的new()。
        new[]和delete[]也可以重载。
        
        实现简单的内存池(simple_memory_pool)
            内存池的概念：
                内存池是预先分配的一大块连续的内存空间，连续的内存空间是为了程序在运行的过程中可以扩展。
            使用内存池的目的：
                1）提升分配和归还的效率
                2）减少内存碎片
           

 
    重载括号运算符(overloading_parenthesis_operators)
        括号运算符()也可以重载，对象名可以当成函数来使用（函数对象、仿函数）。
        括号运算符重载函数的语法：
            返回值类型 operator()(参数列表);
        注意：
            括号运算符必须以成员函数的形式进行重载。
            括号运算符重载函数具备普通函数全部的特征。
            如果函数对象与全局函数同名，按作用域规则选择调用的函数。
        函数对象的用途：
            1）表面像函数，部分场景中可以代替函数，在STL中得到广泛的应用；
            2）函数对象本质是类，可以用成员变量存放更多的信息；
            3）函数对象有自己的数据类型；
            4）可以提供继承体系。

    
    重载一元运算符(overloading_unary_operators)
        可重载的一元运算符。
            1）++ 自增       
            2）-- 自减    
            3）! 逻辑非     
            4）& 取地址
            5）~ 二进制反码  
            6）* 解引用   
            7）+ 一元加    
            8）- 一元求反
        一元运算符通常出现在它们所操作的对象的左边。但是，自增运算符++和自减运算符--有前置和后置之分。
        C++ 规定，重载++或--时，如果重载函数有一个int形参，编译器处理后置表达式时将调用这个重载函数。
        成员函数版：CGirl &operator++();                   // ++前置
        成员函数版：CGirl operator++(int);                 // 后置++
        非成员函数版：CGirl &operator++(CGirl &);          // ++前置
        非成员函数版：CGirl operator++(CGirl &,int);       // 后置++



    自动类型转换(auto_type_conversion)
        对于内置类型，如果两种数据类型是兼容的，C++可以自动转换，如果从更大的数转换为更小的数，可能会被截断或损失精度。
            long count = 8;        // int转换为long
            double time = 11;      // int转换为double
            int side = 3.33         // double转换为int的3
        C++不自动转换不兼容的类型，下面语句是非法的：
            int* ptr = 8;
            不能自动转换时，可以使用强制类型转换：
            int* p = (int*)8;
        如果某种类型与类相关，从某种类型转换为类类型是有意义的。
            string str = "我是一只傻傻鸟。";
        在C++中，将一个参数的构造函数用作自动类型转换函数，它是自动进行的，不需要显式的转换。
            CGirl g1(8);          // 常规的写法。
            CGirl g1 = CGirl(8);   // 显式转换。
            CGirl g1 = 8;         // 隐式转换。
            CGirl g1;             // 创建对象。
            g1 = 8;              // 隐式转换，用CGirl(8)创建临时对象，再赋值给g。
        注意：
            1）一个类可以有多个转换函数。
            2）多个参数的构造函数，除第一个参数外，如果其它参数都有缺省值，也可以作为转换函数。
            3）CGirl(int)的隐式转换的场景：
                将CGirl对象初始化为int值时。  CGirl g1 = 8;
                将int值赋给CGirl对象时。      CGirl g1; g1 = 8;
                将int值传递给接受CGirl参数的函数时。
                返回值被声明为CGirl的函数试图返回int值时。
                在上述任意一种情况下，使用可转换为int类型的内置类型时。
            4）如果自动类型转换有二义性，编译将报错。
        将构造函数用作自动类型转换函数似乎是一项不错的特性，但有时候会导致意外的类型转换。explicit关键字用于关闭这种自动特性，但仍允许显式转换。
            explicit CGirl(int bh);
            CGirl g=8;          // 错误。
            CGirl g=CGirl(8);   // 显式转换，可以。
            CGirl g=(CGirl)8;   // 显式转换，可以。
        在实际开发中，如果强调的是构造，建议使用explicit，如果强调的是类型转换，则不使用explicit。


    转换函数(conversion_func)
        构造函数只用于从某种类型到类类型的转换，如果要进行相反的转换，可以使用特殊的运算符函数-转换函数。
            语法：operator 数据类型();
        注意：转换函数必须是类的成员函数；不能指定返回值类型；不能有参数。
        可以让编译器决定选择转换函数（隐式转换），可以像使用强制类型转换那样使用它们（显式转换）。
            int ii=girl;       // 隐式转换。
            int ii=(int) girl;  // 显式转换。
            int ii=int(girl);   // 显式转换。
        如果隐式转换存在二义性，编译器将报错。
        在C++98中，关键字explicit不能用于转换函数，但C++11消除了这种限制，可以将转换函数声明为显式的。
        还有一种方法是：用一个功能相同的普通成员函数代替转换函数，普通成员函数只有被调用时才会执行。
        int ii=girl.to_int();
        警告：应谨慎的使用隐式转换函数。通常，最好选择仅在被显式地调用时才会执行的成员函数。












拾肆.类继承(014ClassInherit)

    继承的基本概念(class_inherit_basic)
        继承可以理解为一个类从另一个类获取成员变量和成员函数的过程。
            语法：
                class 派生类名:［继承方式］基类名
                {
                    派生类新增加的成员
                };
        被继承的类称为基类或父类，继承的类称为派生类或子类。
        继承和派生是一个概念，只是站的角度不同。
        派生类除了拥有基类的成员，还可以定义新的成员，以增强其功能。
        使用继承的场景：
            1) 如果新创建的类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承。
            2) 当需要创建多个类时，如果它们拥有很多相似的成员变量或成员函数，可以将这些类共同的成员提取出来，定义为基类，然后从基类继承。

    继承方式(inherit_mode)
        类成员的访问权限由高到低依次为：public --> protected --> private，public成员在类外可以访问，private成员只能在类的成员函数中访问。
        如果不考虑继承关系，protected成员和private成员一样，类外不能访问。但是，当存在继承关系时，protected和private就不一样了。基类中的protected成员可以在派生类中访问，而基类中的 private成员不能在派生类中访问。
        继承方式有三种：public（公有的）、protected（受保护的）和private（私有的）。它是可选的，如果不写，那么默认为private。不同的继承方式决定了在派生类中成员函数中访问基类成员的权限。

            1）基类成员在派生类中的访问权限不得高于继承方式中指定的权限。例如，当继承方式为protected时，那么基类成员在派生类中的访问权限最高也为protected，高于protected的会降级为protected，但低于protected不会升级。
                再如，当继承方式为public时，那么基类成员在派生类中的访问权限将保持不变。
                也就是说，继承方式中的public、protected、private是用来指明基类成员在派生类中的最高访问权限的。
            2) 不管继承方式如何，基类中的private成员在派生类中始终不能使用（不能在派生类的成员函数中访问或调用）。
            3) 如果希望基类的成员能够被派生类继承并且毫无障碍地使用，那么这些成员只能声明为public 或protected；只有那些不希望在派生类中使用的成员才声明为private。
            4) 如果希望基类的成员既不向外暴露（不能通过对象访问），还能在派生类中使用，那么只能声明为 protected。
        由于private和protected继承方式会改变基类成员在派生类中的访问权限，导致继承关系复杂，所以，在实际开发中，一般使用public。
        在派生类中，可以通过基类的公有成员函数间接访问基类的私有成员。
        使用 using 关键字可以改变基类成员在派生类中的访问权限。
        注意：
            using只能改变基类中public和protected成员的访问权限，不能改变private成员的访问权限，因为基类中的private成员在派生类中是不可见的，根本不能使用。


    继承的对象模型(inherit_obj_model)
        1）创建派生类对象时，先调用基类的构造函数，再调用派生类的构造函数。
        2）销毁派生类对象时，先调用派生类的析构函数，再调用基类的析构函数。如果手工调用派生类的析构函数，也会调用基类的析构函数。
        3）创建派生类对象时只会申请一次内存，派生类对象包含了基类对象的内存空间，this指针相同的。
        4）创建派生类对象时，先初始化基类对象，再初始化派生类对象。
        5）在VS中，用cl.exe可以查看类的内存模型。
        6）对派生类对象用sizeof得到的是基类所有成员（包括私有成员）+派生类对象所有成员的大小。
        7）在C++中，不同继承方式的访问权限只是语法上的处理。
        8）对派生类对象用memset()会清空基类私有成员。
        9）用指针可以访问到基类中的私有成员（内存对齐）。
        
        查看对象内存布局的方法：
            cl 源文件名 /d1 reportSingleClassLayout类名
            注意：类名不要太短，否则屏幕会显示一大堆东西，找起来很麻烦。
            例如，查看BBB类，源代码文件是demo01.cpp：
            cl demo01.cpp /d1 reportSingleClassLayoutBBB
            
    
    构造基类(structure_basic_class)
        派生类构造函数的要点如下： 
            1）创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。
            2）如果没以指定基类构造函数，将使用基类的默认构造函数。
            3）可以用初始化列表指明要使用的基类构造函数。
            4）基类构造函数负责初始化被继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。
            5）派生类的构造函数总是调用一个基类构造函数，包括拷贝构造函数。


    名字遮蔽与类作用域(name_shield_class_scope)
        如果派生类中的成员（包括成员变量和成员函数）和基类中的成员重名，通过派生类对象或者在派生类的成员函数中使用该成员时，将使用派生类上的成员，而不是基类的。
        注意：基类的成员函数和派生类的成员函数不会构成重载，如果派生类有同名函数，那么就会遮蔽基类中的所有同名函数。
        类是一种作用域，每个类都有它自己的作用域，在这个作用域之内定义成员。
        在类的作用域之外，普通的成员只能通过对象（可以是对象本身，也可以是对象指针或对象引用）来访问，静态成员可以通过对象访问，也可以通过类访问。
        在成员名前面加类名和域解析符可以访问对象的成员。
        如果不存在继承关系，类名和域解析符可以省略不写。
        当存在继承关系时，基类的作用域嵌套在派生类的作用域中。如果成员在派生类的作用域中已经找到，就不会在基类作用域中继续查找；如果没有找到，则继续在基类作用域中查找。
        如果在成员的前面加上类名和域解析符，就可以直接使用该作用域的成员。

    
    继承的特殊关系(special_inherit)
        派生类和基类之间有一些特殊关系。
            1）如果继承方式是公有的，派生类对象可以使用基类成员。
            2）可以把派生类对象赋值给基类对象（包括私有成员），但是，会舍弃非基类的成员。
            3）基类指针可以在不进行显式转换的情况下指向派生类对象。
            4）基类引用可以在不进行显式转换的情况下引用派生类对象。
        注意：
            1）基类指针或引用只能调用基类的方法，不能调用派生类的方法。
            2）可以用派生类构造基类。
            3）如果函数的形参是基类，实参可以用派生类。
            4）C++要求指针和引用类型与赋给的类型匹配，这一规则对继承来说是例外。但是，这种例外只是单向的，不可以将基类对象和地址赋给派生类引用和指针（没有价值，没有讨论的必要）。

    
    多继承与虚继承(more_and_virtual_inherit)
        多继承的语法：
            class 派生类名 : [继承方式1] 基类名1, [继承方式2] 基类名2,......
                {
                    派生类新增加的成员
                };
        域名解析符：
            类名::成员
            例如:
            Person::name
        菱形继承: (多继承的一种特殊情况)
            类B和类C继承自类A,类D又继承自类B和类C,这就是菱形继承
        虚继承可以解决菱形继承的二义性和数据冗余的问题。
        有了多继承，就存在菱形继承，有了菱形继承就有虚继承，增加了复杂性。
        不提倡使用多继承，只有在比较简单和不出现二义性的情况时才使用多继承，能用单一继承解决的问题就不要使用多继承。
        如果继承的层次很多、关系很复杂，程序的编写、调试和维护工作都会变得更加困难，由于这个原因，C++之后的很多面向对象的编程语言，例如 Java、C#、PHP 等，都不支持多继承。















拾伍.类多态(015ClassPolymorphism)
    
    多态的基本概念(polymorphism_base_concept)
        基类指针只能调用基类的成员函数，不能调用派生类的成员函数。
        如果在基类的成员函数前加virtual 关键字，把它声明为虚函数，基类指针就可以调用派生类中同名的成员函数，通过派生类中同名的成员函数，就可以访问派生对象的成员变量。
        有了虚函数，基类指针指向基类对象时就使用基类的成员函数和数据，指向派生类对象时就使用派生类的成员函数和数据，基类指针表现出了多种形式，这种现象称为多态。
        基类引用也可以使用多态。
        注意：
            1）只需要在基类的函数声明中加上virtual关键字，函数定义时不能加。
            2）在派生类中重定义虚函数时，函数特征要相同。
            3）当在基类中定义了虚函数时，如果派生类没有重定义该函数，那么将使用基类的虚函数。
            4）在派生类中重定义了虚函数的情况下，如果想使用基类的虚函数，可以加类名和域解析符。
            5）如果要在派生类中重新定义基类的函数，则将基类函数设置为虚函数；否则，不要设置为虚函数，有两方面的好处：首先效率更高；其次，指出不要重新定义该函数。


    多态的应用场景(polymorphism_application_scenario)

    多态的对象模型(polymorphism_obj_model)
        类的普通成员函数的地址是静态的，在编译阶段已指定。
        如果基类中有虚函数，对象的内存模型中有一个虚函数表，表中存放了基类的函数名和地址。
        如果派生类中重定义了基类的虚函数，创建派生类对象时，将用派生类的函数取代虚函数表中基类的函数。
        
        C++中的多态分为两种：静态多态与动态多态。
        静态多态：也成为编译时的多态；在编译时期就已经确定要执行了的函数地址了；主要有函数重载和函数模板。
        动态多态：即动态绑定，在运行时才去确定对象类型和正确选择需要调用的函数，一般用于解决基类指针或引用派生类对象调用类中重写的方法（函数）时出现的问题。


    如何析构派生类(destruct_derived_classes)
        构造函数不能继承，创建派生类对象时，先执行基类构造函数，再执行派生类构造函数。
        析构函数不能继承，而销毁派生类对象时，先执行派生类析构函数，再执行基类析构函数。
        派生类的析构函数在执行完后，会自动执行基类的析构函数。
        如果手工的调用派生类的析构函数，也会自动调用基类的析构函数。
        析构派生类的要点如下：
            1）析构派生类对象时，会自动调用基类的析构函数。与构造函数不同的是，在派生类的析构函数中不用显式地调用基类的析构函数，因为每个类只有一个析构函数，编译器知道如何选择，无需程序员干涉。
            2）析构函数可以手工调用，如果对象中有堆内存，析构函数中以下代码是必要的：
                delete ptr;
                ptr=nulllptr;
            3）用基类指针指向派生类对象时，delete基类指针调用的是基类的析构函数，不是派生类的，如果希望调用派生类的析构函数，就要把基类的析构函数设置为虚函数。
            4）C++编译器对虚析构函数做了特别的处理。
            5）对于基类，即使它不需要析构函数，也应该提供一个空的虚析构函数。
            6）赋值运算符函数不能继承，派生类继承的函数的特征标与基类完全相同，但赋值运算符函数的特征标随类而异，它包含了一个类型为其所属类的形参。
            7）友元函数不是类成员，不能继承。


    纯虚函数和抽象类(pure_virtual_func_abstract_class)
        纯虚函数是一种特殊的虚函数，在某些情况下，基类中不能对虚函数给出有意义的实现，把它声明为纯虚函数。
        纯虚函数只有函数名、参数和返回值类型，没有函数体，具体实现留给该派生类去做。
        语法：
            virtual 返回值类型 函数名 (参数列表)=0;
        纯虚函数在基类中为派生类保留一个函数的名字，以便派生类它进行重定义。如果在基类中没有保留函数名字，则无法支持多态性。
        含有纯虚函数的类被称为抽象类，不能实例化对象，可以创建指针和引用。
        派生类必须重定义抽象类中的纯虚函数，否则也属于抽象类。
        基类中的纯虚析构函数也需要实现。
        有时候，想使一个类成为抽象类，但刚好又没有任何纯虚函数，怎么办？
            方法很简单：在想要成为抽象类的类中声明一个纯虚析构函数。

    运行阶段类型识别(run_phase_type_identification)
        运行阶段类型识别（RTTI RunTime Type Identification）为程序在运行阶段确定对象的类型，只适用于包含虚函数的类。
        基类指针可以指向派生类对象，如何知道基类指针指向的是哪种派生类的对象呢？（想调用派生类中的非虚函数）。
        dynamic_cast运算符用指向基类的指针来生成派生类的指针，它不能回答“指针指向的是什么类的对象”的问题，但能回答“是否可以安全的将对象的地址赋给特定类的指针”的问题。
        语法：
            派生类指针 = dynamic_cast<派生类类型 *>(基类指针);
        如果转换成功，dynamic_cast返回对象的地址，如果失败，返回nullptr。
        注意：
            1）dynamic_cast只适用于包含虚函数的类。
            2）dynamic_cast可以将派生类指针转换为基类指针，这种画蛇添足的做法没有意义。
            3）dynamic_cast可以用于引用，但是，没有与空指针对应的引用值，如果转换请求不正确，会出现bad_cast异常。

    
    typeid运算符和type_info类(typeid_and_typeinfoclass)
        typeid运算符用于获取数据类型的信息。
        语法一：
            typeid(数据类型);
        语法二：
            typeid(变量名或表达式);
        typeid运算符返回type_info类（在头文件<typeinfo>中定义）的对象的引用。
        type_info类的实现随编译器而异，但至少有name()成员函数，该函数返回一个字符串，通常是类名。
        type_info重载了==和!=运算符，用于对类型进行比较。
        注意：
            1）type_info类的构造函数是private属性，也没有拷贝构造函数，所以不能直接实例化，只能由编译器在内部实例化。
            2）不建议用name()成员函数返回的字符串作为判断数据类型的依据。（编译器可能会转换类型名）
            3）typeid运算符可以用于多态的场景，在运行阶段识别对象的数据类型。
            4）假设有表达式typeid(*ptr)，当ptr是空指针时，如果ptr是多态的类型，将引发bad_typeid异常。











拾陆.函数模版(016FuncTemplate)
    
    自动推导类型auto(auto_deduce_type)
        在C语言和C++98中，auto关键字用于修饰变量（自动存储的局部变量）。
        在C++11中，赋予了auto全新的含义，不再用于修饰变量，而是作为一个类型指示符，指示编译器在编译时推导auto声明的变量的数据类型。
        语法：auto 变量名 = 初始值;
        在Linux平台下，编译需要加-std=c++11参数。
        注意：
            1）auto声明的变量必须在定义时初始化。
            2）初始化的右值可以是具体的数值，也可以是表达式和函数的返回值等。
            3）auto不能作为函数的形参类型。
            4）auto不能直接声明数组。
            5）auto不能定义类的非静态成员变量。
        不要滥用auto，auto在编程时真正的用途如下：
            1）代替冗长复杂的变量声明。
            2）在模板中，用于声明依赖模板参数的变量。
            3）函数模板依赖模板参数的返回值。
            4）用于lambda表达式中。

    函数模版的基本概念(func_template_basic)
        函数模板是通用的函数描述，使用任意类型（泛型）来描述函数。
        编译的时候，编译器推导实参的数据类型，根据实参的数据类型和函数模板，生成该类型的函数定义。
        生成函数定义的过程被称为实例化。
        创建交换两个变量的函数模板：
            template <typename T>
            void Swap(T &a, T &b)
            {
                T tmp = a;
                a = b;
                b = tmp;
            }
        在C++98添加关键字typename之前，C++使用关键字class来创建模板。
        如果考虑向后兼容，函数模板应使用typename，而不是class。
        函数模板实例化可以让编译器自动推导，也可以在调用的代码中显式的指定。
    
    
    函数模版的注意事项(func_template_precautions)
        1）可以为类的成员函数创建模板，但不能是虚函数和析构函数。
        2）使用函数模板时，必须明确数据类型，确保实参与函数模板能匹配上。
        3）使用函数模板时，推导的数据类型必须适应函数模板中的代码。
        4）使用函数模板时，如果是自动类型推导，不会发生隐式类型转换，如果显式指定了函数模板的数据类型，可以发生隐式类型转换。
        5）函数模板支持多个通用数据类型的参数。
        6）函数模板支持重载，可以有非通用数据类型的参数。


    函数模板的具体化(func_template_specific)
        可以提供一个具体化的函数定义，当编译器找到与函数调用匹配的具体化定义时，将使用该定义，不再寻找模板。
        具体化（特例化、特化）的语法：
            template<> void 函数模板名<数据类型>(参数列表)
            template<> void 函数模板名 (参数列表)
            {
            // 函数体。
            }
        对于给定的函数名，可以有普通函数、函数模板和具体化的函数模板，以及它们的重载版本。
        编译器使用各种函数的规则：
            1）具体化优先于常规模板，普通函数优先于具体化和常规模板。
            2）如果希望使用函数模板，可以用空模板参数强制使用函数模板。
            3）如果函数模板能产生更好的匹配，将优先于普通函数。


    函数模板高级(func_template_advanced)
        1）decltype关键字
            在C++11中，decltype操作符，用于查询表达式的数据类型。
                语法：decltype(expression) var;
            decltype分析表达式并得到它的类型，不会计算执行表达式。函数调用也一种表达式，因此不必担心在使用decltype时执行了函数。
            decltype推导规则（按步骤）：
                1）如果expression是一个没有用括号括起来的标识符，则var的类型与该标识符的类型相同，包括const等限定符。
                2）如果expression是一个函数调用，则var的类型与函数的返回值类型相同（函数不能返回void，但可以返回void *）。
                3）如果expression是一个左值（能取地址）(要排除第一种情况)、或者用括号括起来的标识符，那么var的类型是expression的引用。
                4）如果上面的条件都不满足，则var的类型与expression的类型相同。
            如果需要多次使用decltype，可以结合typedef和using。
        2）函数后置返回类型
                int func(int x,double y);
            等同：
                auto func(int x,double y) -> int;
            将返回类型移到了函数声明的后面。
            auto是一个占位符（C++11给auto新增的角色）, 为函数返回值占了一个位置。
            这种语法也可以用于函数定义：
                auto func(int x,double y) -> int
                {
                    // 函数体。
                }
        3）C++14的auto关键字
            C++14标准对函数返回类型推导规则做了优化，函数的返回值可以用auto，不必尾随返回类型。
            示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template <typename T1, typename T2>
            auto func(T1 x, T2 y) -> decltype(x + y)
            {
                decltype(x+y)  tmp = x + y;
                cout << "tmp=" << tmp << endl;
                return tmp;
            }
            
            int main()
            {
                func(3, 5.8);
            }













拾柒.类模版(017ClassTemplate)
    
    模板类的基本概念(class_template_basic)
        类模板是通用类的描述，使用任意类型（泛型）来描述类的定义。
        使用类模板的时候，指定具体的数据类型，让编译器生成该类型的类定义。
        语法：
            template <class T>
            class 类模板名
            {
                类的定义;
            };
        函数模板建议用typename描述通用数据类型，类模板建议用class。
        注意：
            1）在创建对象的时候，必须指明具体的数据类型。
            2）使用类模板时，数据类型必须适应类模板中的代码。
            3）类模板可以为通用数据类型指定缺省的数据类型（C++11标准的函数模板也可以）。
            4）模板类的成员函数可以在类外实现。
            5）可以用new创建模板类对象。
            6）在程序中，模板类的成员函数使用了才会创建。
        
    模版类的示例-栈(template_class_stack)
    模版类的示例-数组(template_class_array)
        类模板可以有非通用类型参数：
            1）通常是整型（C++20标准可以用其它）；
            2）实例化模板时必须用常量表达式；
            3）模板中不能修改参数的值；
            4）可以为非通用类型参数提供默认值。
        优点：在栈上分配内存，易维护，执行速度快，合适小型数组。
        缺点：在程序中，不同的非通用类型参数将导致编译器生成不同的类。
        构造函数的方法更通用，因为数据的大小是类的成员（而不是硬编码），可以创建数组大小可变的类。

    嵌套和递归使用模版类(joint_and_recursive_use_of_templates)
        在C++11之前，嵌套使用模板类的时候，> >之间要加空格。
        
    模版类的具体化(template_class_specific)
        模板类具体化（特化、特例化）有两种：完全具体化和部分具体化。
        语法请见示例程序。
        具体化程度高的类优先于具体化程度低的类，具体化的类优先于没有具体化的类。
        具体化的模板类，成员函数类外实现的代码应该放在源文件中。
    
    模板类与继承(template_class_inherit)
        1）模板类继承普通类（常见）。
        2）普通类继承模板类的实例化版本。
        3）普通类继承模板类。(常见)
        4）模板类继承模板类。
        5）模板类继承模板参数给出的基类（不能是模板类）。
        
        1）模板类继承普通类
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            class AA     // 普通类AA。
            {
            public:
            int m_a;
            AA(int a) :m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            template<class T1, class T2>
            class BB:public AA      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y,int a) : AA(a) , m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            int main()
            {
            BB<int, string> bb(8, "我是一只傻傻鸟。",3);
            bb.func2();
            bb.func1();
            }
        
        2）普通类继承模板类的实例化版本
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            class AA:public BB<int,string>     // 普通类AA。
            {
            public:
            int m_a;
            AA(int a,int x,string y) : BB(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            AA aa(3,8, "我是一只傻傻鸟。");
            aa.func1();
            aa.func2();
            }
        
        3）普通类继承模板类。
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            template<class T1, class T2>
            class AA:public BB<T1,T2>     // 普通类AA变成了模板类，才能继承模板类。
            {
            public:
            int m_a;
            AA(int a, const T1 x, const T2 y) : BB<T1,T2>(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            AA<int,string> aa(3,8, "我是一只傻傻鸟。");
            aa.func1();
            aa.func2();
            }

        4）模板类继承模板类。
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class BB      // 模板类BB。
            {
            public:
            T1 m_x;
            T2 m_y;
            BB(const T1 x, const T2 y) : m_x(x), m_y(y) { cout << "调用了BB的构造函数。\n"; }
            void func2() const { cout << "调用了func2()函数：x = " << m_x << ", y = " << m_y << endl; }
            };
            
            template<class T1, class T2>
            class AA:public BB<T1,T2>     // 普通类AA变成了模板类，才能继承模板类。
            {
            public:
            int m_a;
            AA(int a, const T1 x, const T2 y) : BB<T1,T2>(x,y),m_a(a) { cout << "调用了AA的构造函数。\n"; }
            void func1() { cout << "调用了func1()函数：m_a=" << m_a << endl;; }
            };
            
            template<class T, class T1, class T2>
            class CC :public BB<T1, T2>   // 模板类继承模板类。
            {
            public:
            T m_a;
            CC(const T a, const T1 x, const T2 y) : BB<T1, T2>(x, y), m_a(a) { cout << "调用了CC的构造函数。\n"; }
            void func3() { cout << "调用了func3()函数：m_a=" << m_a << endl;; }
            };
            
            int main()
            {
            CC<int,int,string> cc(3,8, "我是一只傻傻鸟。");
            cc.func3();
            cc.func2();
            }
        
        5）模板类继承模板参数给出的基类
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            class AA {
            public:
            AA()         { cout << "调用了AA的构造函数AA()。\n"; }
            AA(int a) { cout << "调用了AA的构造函数AA(int a)。\n"; }
            };
            
            class BB {
            public:
            BB()         { cout << "调用了BB的构造函数BB()。\n"; }
            BB(int a) { cout << "调用了BB的构造函数BB(int a)。\n"; }
            };
            
            class CC {
            public:
            CC()         { cout << "调用了CC的构造函数CC()。\n"; }
            CC(int a) { cout << "调用了CC的构造函数CC(int a)。\n"; }
            };
            
            template<class T>
            class DD {
            public:
            DD()         { cout << "调用了DD的构造函数DD()。\n"; }
            DD(int a) { cout << "调用了DD的构造函数DD(int a)。\n"; }
            };
            
            template<class T>
            class EE : public T {          // 模板类继承模板参数给出的基类。
            public:
            EE() :T()           { cout << "调用了EE的构造函数EE()。\n"; }
            EE(int a) :T(a) { cout << "调用了EE的构造函数EE(int a)。\n"; }
            };
            
            int main()
            {
            EE<AA> ea1;                 // AA作为基类。
            EE<BB> eb1;                 // BB作为基类。
            EE<CC> ec1;                 // CC作为基类。
            EE<DD<int>> ed1;      // EE<int>作为基类。
            // EE<DD> ed1;                // DD作为基类，错误。
            }

    模板类与函数(template_class_func)
        模板类可以用于函数的参数和返回值，有三种形式：
            1）普通函数，参数和返回值是模板类的实例化版本。
            2）函数模板，参数和返回值是某种的模板类。
            3）函数模板，参数和返回值是任意类型（支持普通类和模板类和其它类型）。
    
    模板类与友元(template_class_friendship)
        模板类的友元函数有三类：
            1）非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数。
            2）约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。
            3）非约束模板友元：模板类实例化时，如果实例化了n个类，也会实例化n个友元函数，每个实例化的类都拥有n个友元函数。


        1）非模板友元示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            template<class T1, class T2>
            class AA    
            {
            T1 m_x;
            T2 m_y;
            public:
            AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            // 非模板友元：友元函数不是模板函数，而是利用模板类参数生成的函数，只能在类内实现。
            friend void show(const AA<T1, T2>& a)
            {
            cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            /* friend void show(const AA<int, string>& a);
            friend void show(const AA<char, string>& a);*/
            };
            
            //void show(const AA<int, string>& a)
            //{
            //    cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            //}
            //
            //void show(const AA<char, string>& a)
            //{
            //    cout << "x = " << a.m_x << ", y = " << a.m_y << endl;
            //}
            
            int main()
            {
            AA<int, string> a(88, "我是一只傻傻鸟。");
            show(a);
            
                AA<char, string> b(88, "我是一只傻傻鸟。");
                show(b);
            }
        
        2）约束模板友元示例：
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            // 约束模板友元：模板类实例化时，每个实例化的类对应一个友元函数。
            template <typename T>
            void show(T& a);                                                 // 第一步：在模板类的定义前面，声明友元函数模板。
            
            template<class T1, class T2>
            class AA    // 模板类AA。
            {
            friend void show<>(AA<T1, T2>& a);          // 第二步：在模板类中，再次声明友元函数模板。
            T1 m_x;
            T2 m_y;
            
            public:
            
                AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template<class T1, class T2>
            class BB    // 模板类BB。
            {
            friend void show<>(BB<T1, T2>& a);          // 第二步：在模板类中，再次声明友元函数模板。
            T1 m_x;
            T2 m_y;
            
            public:
            
                BB(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template <typename T>                                 // 第三步：友元函数模板的定义。
            void show(T& a)
            {
            cout << "通用：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>                                                    // 第三步：具体化版本。
            void show(AA<int, string>& a)
            {
            cout << "具体AA<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>                                                    // 第三步：具体化版本。
            void show(BB<int, string>& a)
            {
            cout << "具体BB<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            int main()
            {
            AA<int, string> a1(88, "我是一只傻傻鸟。");
            show(a1);         // 将使用具体化的版本。
            
                AA<char, string> a2(88, "我是一只傻傻鸟。");
                show(a2);        // 将使用通用的版本。
            
                BB<int, string> b1(88, "我是一只傻傻鸟。");
                show(b1);         // 将使用具体化的版本。
            
                BB<char, string> b2(88, "我是一只傻傻鸟。");
                show(b2);        // 将使用通用的版本。
            }
        3）非约束模板友元
            #include <iostream>         // 包含头文件。
            using namespace std;        // 指定缺省的命名空间。
            
            // 非类模板约束的友元函数，实例化后，每个函数都是每个每个类的友元。
            template<class T1, class T2>
            class AA    
            {
            template <typename T> friend void show(T& a);     // 把函数模板设置为友元。
            T1 m_x;
            T2 m_y;
            public:
            AA(const T1 x, const T2 y) : m_x(x), m_y(y) { }
            };
            
            template <typename T> void show(T& a)                     // 通用的函数模板。
            {
            cout << "通用：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            template <>void show(AA<int, string>& a)                 // 函数模板的具体版本。
            {
            cout << "具体<int, string>：x = " << a.m_x << ", y = " << a.m_y << endl;
            }
            
            int main()
            {
                AA<int, string> a(88, "我是一只傻傻鸟。");
                show(a);         // 将使用具体化的版本。
        
                AA<char, string> b(88, "我是一只傻傻鸟。");
                show(b);        // 将使用通用的版本。
            }
        
    模板类的成员模板(member_template_class)
        
    将模板类用作参数(params_template_class)














拾捌.Cpp编译链接和命名空间(018CompileLinkNamingSapce)

    编译预处理(compile_processing)
        C++程序编译的过程：预处理 -> 编译（优化、汇编）-> 链接
        预处理指令主要有以下三种：
            包含头文件：#include
            宏定义：#define（定义宏）、#undef（删除宏）。
            条件编译：#ifdef、#ifndef。
        
        1）包含头文件
            #include 包含头文件有两种方式：
                #include <文件名>：直接从编译器自带的函数库目录中寻找文件。
                #include "文件名"：先从自定义的目录中寻找文件，如果找不到，再从编译器自带的函数库目录中寻找。
            #include也包含其它的文件，如：*.h、*.cpp或其它的文件。
            C++98标准后的头文件：
                C的标准库：老版本的有.h后缀；新版本没有.h的后缀，增加了字符c的前缀。例如：老版本是<stdio.h>，新版本是<cstdio>，新老版本库中的内容是一样的。在程序中，不指定std命名空间也能使用库中的内容。
                C++的标准库：老版本的有.h后缀；新版本没有.h的后缀。例如：老版本是<iostream.h>，新版本是<iostream>，老版本已弃用，只能用新版本。在程序中，必须指定std命名空间才能使用库中的内容。
            注意：用户自定义的头文件还是用.h为后缀。
        
        2）宏定义指令
            无参数的宏：#define 宏名  宏内容
            有参数的宏：#define MAX(x,y)  ((x)>(y) ? (x) : (y))    MAX(3,5)  ((3)>(5) ? (3) : (5))
            编译的时候，编译器把程序中的宏名用宏内容替换，是为宏展开（宏替换）。
            宏可以只有宏名，没有宏内容。
            在C++中，内联函数可代替有参数的宏，效果更好。
            C++中常用的宏：
                当前源代码文件名：__FILE__
                当前源代码函数名：__FUNCTION__
                当前源代码行号：__LINE__
                编译的日期：__DATE__
                编译的时间：__TIME__
                编译的时间戳：__TIMESTAMP__
            当用C++编译程序时，宏__cplusplus就会被定义。
        
        3）条件编译
            最常用的两种：#ifdef、#ifndef    if #define  if not #define
            #ifdef 宏名
            程序段一
            #else
            程序段二
            #endif
            含义：如果#ifdef后面的宏名已存在，则使用程序段一，否则使用程序段二。
            #ifndef 宏名
            程序段一
            #else
            程序段二
            #endif
            含义：如果#ifndef后面的宏名不存在，则使用程序段一，否则使用序段二。
        
        4）解决头文件中代码重复包含的问题
            在C/C++中，在使用预编译指令#include的时候，为了防止头文件被重复包含，有两种方式。
            第一种：用#ifndef指令。
                #ifndef _GIRL_
                #define _GIRL_
                //代码内容。
                #endif
            第二种：把#pragma once指令放在文件的开头。
                #ifndef方式受C/C++语言标准的支持，不受编译器的任何限制；
                    而#pragma once方式有些编译器不支持。
                #ifndef可以针对文件中的部分代码；而#pragma once只能针对整个文件。
                #ifndef更加灵活，兼容性好；#pragma once操作简单，效率高。
        
    编译和链接(compile_and_link)
        一、源代码的组织
            头文件（*.h）：#include头文件、函数的声明、结构体的声明、类的声明、模板的声明、内联函数、#define和const定义的常量等。
            源文件（*.cpp）：函数的定义、类的定义、模板具体化的定义。
            主程序（main函数所在的程序）：主程序负责实现框架和核心流程，把需要用到的头文件用#include包含进来。
        二、编译预处理
            预处理的包括以下方面：
            1）处理#include头文件包含指令。
            2）处理#ifdef #else #endif、#ifndef #else #endif条件编译指令。
            3）处理#define宏定义。
            4）为代码添加行号、文件名和函数名。
            5）删除注释。
            6）保留部分#pragma编译指令（编译的时候会用到）。
        三、编译
            将预处理生成的文件，经过词法分析、语法分析、语义分析以及优化和汇编后，编译成若干个目标文件（二进制文件）。
        四、链接
            将编译后的目标文件，以及它们所需要的库文件链接在一起，形成一个整体。
        五、更多细节
            1）分开编译的好处：每次只编译修改过的源文件，然后再链接，效率最高。
            2）编译单个*.cpp文件的时候，必须要让编译器知道名称的存在，否则会出现找不到标识符的错误。（直接和间接包含头文件都可以）
            3）编译单个*.cpp文件的时候，编译器只需要知道名称的存在，不会把它们的定义一起编译。
            4）如果函数和类的定义不存在，编译不会报错，但链接会出现无法解析的外部命令。
            5）链接的时候，变量、函数和类的定义只能有一个，否则会出现重定义的错误。（如果把变量、函数和类的定义放在*.h文件中，*.h会被多次包含，链接前可能存在多个副本；如果放在*.cpp文件中，*.cpp文件不会被包含，只会被编译一次，链接前只存在一个版本）
            6）把变量、函数和类的定义放在*.h中是不规范的做法，如果*.h被多个*.cpp包含，会出现重定义。
            7）用#include包含*.cpp也是不规范的做法，原理同上。
            8）尽可能不使用全局变量，如果一定要用，要在*.h文件中声明（需要加extern关键字），在*.cpp文件中定义。
            9）全局的const常量在头文件中定义（const常量仅在单个文件内有效）。
            10）*.h文件重复包含的处理方法只对单个的*.cpp文件有效，不是整个项目。
            11）函数模板和类模板的声明和定义可以分开书写，但它们的定义并不是真实的定义，只能放在*.h文件中；函数模板和类模板的具体化版本的代码是真实的定义，所以放在*.cpp文件中。
            12）Linux下C++编译和链接的原理与VS一样。
    
    命名空间(naming_space)
        在实际开发中，较大型的项目会使用大量的全局名字，如类、函数、模板、变量等，很容易出现名字冲突的情况。
        命名空间分割了全局空间，每个命名空间是一个作用域，防止名字冲突。
        一、语法
            创建命名空间：
            namespace 命名空间的名字
            {
            // 类、函数、模板、变量的声明和定义。
            }
            创建命名空间的别名：
            namespace 别名=原名;
        二、使用命名空间
            在同一命名空间内的名字可以直接访问，该命名空间之外的代码则必须明确指出命名空间。
            1）运算符::
            语法：命名空间::名字
            简单明了，且不会造成任何冲突，但使用起来比较繁琐。
            2）using声明
            语法：using 命名空间::名字
            用using声明名后，就可以进行直接使用名称。
            如果该声明区域有相同的名字，则会报错。
            3）using编译指令
            语法：using namespace命名空间
            using编译指令将使整个命名空间中的名字可用。如果声明区域有相同的名字，局部版本将隐藏命名空间中的名字，不过，可以使用域名解析符使用命名空间中的名称。
        四、注意事项
            1）命名空间是全局的，可以分布在多个文件中。
            2）命名空间可以嵌套。
            3）在命名空间中声明全局变量，而不是使用外部全局变量和静态变量。
            4）对于using声明，首选将其作用域设置为局部而不是全局。
            5）不要在头文件中使用using编译指令，如果非要使用，应将它放在所有的#include之后。
            6）匿名的命名空间，从创建的位置到文件结束有效。

    类型转换static_cast(type_trans_static_cast)
        C风格的类型转换很容易理解：
        语法：
            (目标类型)表达式或目标类型(表达式);
        C++认为C风格的类型转换过于松散，可能会带来隐患，不够安全。
        C++推出了新的类型转换来替代C风格的类型转换，采用更严格的语法检查，降低使用风险。
        C++新增了四个关键字static_cast、const_cast、reinterpret_cast和dynamic_cast，用于支持C++风格的类型转换。
        C++的类型转换只是语法上的解释，本质上与C风格的类型转换没什么不同，C语言做不到事情的C++也做不到。
        语法：
            static_cast<目标类型>(表达式);
            const_cast<目标类型>(表达式);
            reinterpret_cast<目标类型>(表达式);
            dynamic_cast<目标类型>(表达式);

        一、static_cast
            1）用于内置数据类型之间的转换
                除了语法不同，C和C++没有区别。
                #include <iostream>
                using namespace std;
                
                int main(int argc, char* argv[])
                {
                int    ii = 3;
                long ll = ii;                     // 绝对安全，可以隐式转换，不会出现警告。
                
                    double dd = 1.23;
                    long ll1 = dd;                  // 可以隐式转换，但是，会出现可能丢失数据的警告。
                    long ll2 = (long)dd;              // C风格：显式转换，不会出现警告。
                    long ll3 = static_cast<long>(dd);    // C++风格：显式转换，不会出现警告。
                    cout << "ll1=" << ll1 << ",ll2=" << ll2 << ",ll3=" << ll3 << endl;
                }
            2）用于指针之间的转换
                C风格可以把不同类型的指针进行转换。
                C++不可以，需要借助void *。
                #include <iostream>
                using namespace std;
                
                void func(void* ptr) {   // 其它类型指针 -> void *指针 -> 其它类型指针
                double* pp = static_cast<double*>(ptr);
                }
                
                int main(int argc, char* argv[])
                {
                int ii = 10;
                
                    //double* pd1 = &ii;                      // 错误，不能隐式转换。
                    double* pd2 = (double*) &ii;      // C风格，强制转换。
                    //double* pd3 = static_cast<double*>(&ii);    // 错误，static_cast不支持不同类型指针的转换。
                
                    void* pv = &ii;                               // 任何类型的指针都可以隐式转换成void*。
                    double* pd4 = static_cast<double*>(pv);  // static_cast可以把void *转换成其它类型的指针。
                    func(&ii);
                }
        
        二、const_cast
            static_cast不能丢掉指针（引用）的const和volitale属性，const_cast可以。
            示例：
                #include <iostream>
                using namespace std;
                
                void func(int *ii)
                {}
                
                int main(int argc, char* argv[])
                {
                const int *aa=nullptr;
                int *bb = (int *)aa;                          // C风格，强制转换，丢掉const限定符。
                int* cc = const_cast<int*>(aa);      // C++风格，强制转换，丢掉const限定符。
                
                    func(const_cast<int *>(aa));
                }
        三、reinterpret_cast
            static_cast不能用于转换不同类型的指针（引用）（不考虑有继承关系的情况），reinterpret_cast可以。
            reinterpret_cast的意思是重新解释，能够将一种对象类型转换为另一种，不管它们是否有关系。
            语法：
                reinterpret_cast<目标类型>(表达式);
            <目标类型>和(表达式)中必须有一个是指针（引用）类型。
            reinterpret_cast不能丢掉(表达式)的const或volitale属性。
            应用场景：
                1）reinterpret_cast的第一种用途是改变指针（引用）的类型。
                2）reinterpret_cast的第二种用途是将指针（引用）转换成整型变量。整型与指针占用的字节数必须一致，否则会出现警告，转换可能损失精度。
                3）reinterpret_cast的第三种用途是将一个整型变量转换成指针（引用）。
            示例：
                #include <iostream>
                using namespace std;
                
                void func(void* ptr) {  
                long long ii = reinterpret_cast<long long>(ptr);
                cout << "ii=" << ii << endl;
                }
                
                int main(int argc, char* argv[])
                {
                long long ii = 10;
                
                    func(reinterpret_cast<void *>(ii));
                }
            









拾玖.STL容器和算法(019STLContainerAndAlgorithm)

    string容器(string_container)
        string是字符容器，内部维护了一个动态的字符数组。
        与普通的字符数组相比，string容器有三个优点：
            1）使用的时候，不必考虑内存分配和释放的问题；
            2）动态管理内存（可扩展）；
            3）提供了大量操作容器的API。
        缺点是效率略有降低，占用的资源也更多。
        string类是std::basic_string类模板的一个具体化版本的别名。
        
        构造和析构
            静态常量成员string::npos为字符数组的最大长度（通常为unsigned int的最大值）；
            NBTS（null-terminated string）：C风格的字符串（以空字符0结束的字符串）。
            string类有七个构造函数（C++11新增了两个）：
                1）string(); // 创建一个长度为0的string对象（默认构造函数）。
                2）string(const char *s); // 将string对象初始化为s指向的NBTS（转换函数）。
                3）string(const string &str); // 将string对象初始化为str（拷贝构造函数）。
                4）string(const char *s,size_t n); // 将string对象初始化为s指向的地址后n字节的内容。
                5）string(const string &str,size_t pos=0,size_t n=npos); // 将sring对象初始化为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。
                6）template<class T> string(T begin,T end); // 将string对象初始化为区间[begin,end]内的字符，其中begin和end的行为就像指针，用于指定位置，范围包括begin在内，但不包括end。
                7）string(size_t n,char c); // 创建一个由n个字符c组成的string对象。
            析构函数~string()释放内存空间。
            C++11新增的构造函数：
                1）string(string && str) noexcept：它将一个string对象初始化为string对象str，并可能修改str（移动构造函数）。
                2）string(initializer_list<char> il)：它将一个string对象初始化为初始化列表il中的字符。
                例如：string ss = { 'h','e','l','l','o' };

        特性操作
            size_t max_size() const;    // 返回string对象的最大长度string::npos，此函数意义不大。
            size_t capacity() const;     // 返回当前容量，可以存放字符的总数。
            size_t length() const;      // 返回容器中数据的大小（字符串语义）。
            size_t size() const;         // 返回容器中数据的大小（容器语义）。
            bool empty() const;     // 判断容器是否为空。
            void clear();             // 清空容器。
            void shrink_to_fit();	      // 将容器的容量降到实际大小（需要重新分配内存）。
            void reserve( size_t size=0);  // 将容器的容量设置为至少size。
            void resize(size_t len,char c=0);  // 把容器的实际大小置为len，如果len<实际大小，会截断多出的部分；如果len>实际大小，就用字符c填充。
        字符操作
            char &operator[](size_t n);
            const char &operator[](size_t n) const;  // 只读。
            char &at(size_t n);
            const char &at(size_t n) const;          // 只读。
            operator[]和at()返回容器中的第n个元素，但at函数提供范围检查，当越界时会抛出out_of_range异常，operator[]不提供范围检查。
            const char *c_str() const; // 返回容器中动态数组的首地址，语义：寻找以null结尾的字符串。
            const char *data() const; // 返回容器中动态数组的首地址，语义：只关心容器中的数据。
            int copy(char *s, int n, int pos = 0) const; // 把当前容器中的内容，从pos开始的n个字节拷贝到s中，返回实际拷贝的数目。
        赋值操作
            给已存在的容器赋值，将覆盖容器中原有的内容。
            1）string &operator=(const string &str); // 把容器str赋值给当前容器。
            2）string &assign(const char *s); // 将string对象赋值为s指向的NBTS。
            3）string &assign(const string &str); // 将string对象赋值为str。
            4）string &assign(const char *s,size_t n); // 将string对象赋值为s指向的地址后n字节的内容。
            5）string &assign(const string &str,size_t pos=0,size_t n=npos); // 将sring对象赋值为str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）。
            6）template<class T> string &assign(T begin,T end); // 将string对象赋值为区间[begin,end]内的字符。
            7）string &assign(size_t n,char c); // 将string对象赋值为由n个字符c。
        连接操作
            把内容追加到已存在容器的后面。
            1）string &operator+=(const string &str); //把容器str连接到当前容器。
            2）string &append(const char *s); // 把指向s的NBTS连接到当前容器。
            3）string &append(const string &str); // 把容器str连接到当前容器。
            4）string &append(const char *s,size_t n); // 将s指向的地址后n字节的内容连接到当前容器。
            5）string &append(const string &str,size_t pos=0,size_t n=npos); // 将str从位置pos开始到结尾的字符（或从位置pos开始的n个字符）连接到当前容器。
            6）template<class T> string &append (T begin,T end); // 将区间[begin,end]内的字符连接到容器。
            7）string &append(size_t n,char c); // 将n个字符c连接到当前容器。
        交换操作
            void swap(string &str);    // 把当前容器与str交换。
            如果数据量很小，交换的是动态数组中的内容，如果数据量比较大，交换的是动态数组的地址。
        截取操作
            string substr(size_t pos = 0,size_t n = npos) const; // 返回pos开始的n个字节组成的子容器。
        比较操作
            bool operator==(const string &str1,const string &str2) const; // 比较两个字符串是否相等。
            int compare(const string &str) const; // 比较当前字符串和str1的大小。
            int compare(size_t pos, size_t n,const string &str) const; // 比较当前字符串从pos开始的n个字符组成的字符串与str的大小。
            int compare(size_t pos, size_t n,const string &str,size_t pos2,size_t n2)const; // 比较当前字符串从pos开始的n个字符组成的字符串与str中pos2开始的n2个字符组成的字符串的大小。
            以下几个函数用于和C风格字符串比较。
            int compare(const char *s) const;
            int compare(size_t pos, size_t n,const char *s) const;
            int compare(size_t pos, size_t n,const char *s, size_t pos2) const;
        查找操作
            size_t find(const string& str, size_t pos = 0) const;
            size_t find(const char* s, size_t pos = 0) const;
            size_t find(const char* s, size_t pos, size_t n) const;
            size_t find(char c, size_t pos = 0) const;
            
            size_t rfind(const string& str, size_t pos = npos) const;
            size_t rfind(const char* s, size_t pos = npos) const;
            size_t rfind(const char* s, size_t pos, size_t n) const;
            size_t rfind(char c, size_t pos = npos) const;
            
            size_t find_first_of(const string& str, size_t pos = 0) const;
            size_t find_first_of(const char* s, size_t pos = 0) const;
            size_t find_first_of(const char* s, size_t pos, size_t n) const;
            size_t find_first_of(char c, size_t pos = 0) const;
            
            size_t find_last_of(const string& str, size_t pos = npos) const;
            size_t find_last_of(const char* s, size_t pos = npos) const;
            size_t find_last_of(const char* s, size_t pos, size_t n) const;
            size_t find_last_of(char c, size_t pos = npos) const;
            
            size_t find_first_not_of(const string& str, size_t pos = 0) const;
            size_t find_first_not_of(const char* s, size_t pos = 0) const;
            size_t find_first_not_of(const char* s, size_t pos, size_t n) const;
            size_t find_first_not_of(char c, size_t pos = 0) const;
            
            size_t find_last_not_of(const string& str, size_t pos = npos) const;
            size_t find_last_not_of(const char* s, size_t pos = npos) const;
            size_t find_last_not_of(const char* s, size_t pos, size_t n) const;
            size_t find_last_not_of(char c, size_t pos = npos) const;
        替换操作
            string& replace(size_t pos, size_t len, const string& str);
            string& replace(size_t pos, size_t len, const string& str, size_t subpos, size_t sublen = npos);
            string& replace(size_t pos, size_t len, const char* s);
            string& replace(size_t pos, size_t len, const char* s, size_t n);
            string& replace(size_t pos, size_t len, size_t n, char c);
            以下函数意义不大。
            string& replace(iterator i1, iterator i2, const string& str);
            string& replace(iterator i1, iterator i2, const char* s);
            string& replace(iterator i1, iterator i2, const char* s, size_t n);
            string& replace(iterator i1, iterator i2, size_t n, char c);
            template <class InputIterator>
            string& replace(iterator i1, iterator i2, InputIterator first, InputIterator last);
        插入操作
            string& insert(size_t pos, const string& str);
            string& insert(size_t pos, const string& str, size_t subpos, size_t sublen = npos);
            string& insert(size_t pos, const char* s);
            string& insert(size_t pos, const char* s, size_t n);
            string& insert(size_t pos, size_t n, char c);
            以下函数意义不大。
            iterator insert(iterator p, size_t n, char c);
            iterator insert(iterator p, char c);
            template <class InputIterator>
            iterator insert(iterator p, InputIterator first, InputIterator last);
        删除操作
            string &erase(size_t pos = 0, size_t n = npos); // 删除pos开始的n个字符。
            以下函数意义不大。
            iterator erase(iterator it); // 删除it指向的字符，返回删除后迭代器的位置。
            iterator erase(iterator first, iterator last); / /删除[first，last）之间的所有字符，返回删除后迭代器的位置。
        
    vector容器(vector_container)
        vector容器封装了动态数组。
        包含头文件 #include<vector>
        vector类模板的声明：
            template<class T, class Alloc = allocator<T>>
            class vector{
            private:
            T *start_;
            T *finish_;
            T *end_;
            ……
            }
        分配器
            各种STL容器模板都接受一个可选的模板参数，该参数指定使用哪个分配器对象来管理内存
            如果省略该模板参数的值，将默认使用allocator<T>，用new和delete分配和释放内存。
        构造函数
            1）vector();  // 创建一个空的vector容器。
            2）vector(initializer_list<T> il); // 使用统一初始化列表。
            3）vector(const vector<T>& v);  // 拷贝构造函数。
            4）vector(Iterator first, Iterator last);  // 用迭代器创建vector容器。
            5）vector(vector<T>&& v);  // 移动构造函数（C++11标准）。
            6）explicit vector(const size_t n);   // 创建vector容器，元素个数为n（容量和实际大小都是n）。
            7）vector(const size_t n, const T& value);  // 创建vector容器，元素个数为n，值均为value。
            析构函数~vector()释放内存空间。
        特性操作
            size_t max_size() const;     // 返回容器的最大长度，此函数意义不大。
            size_t capacity() const;      // 返回容器的容量。
            size_t size() const;          // 返回容器的实际大小（已使用的空间）。
            bool empty() const;        // 判断容器是否为空。
            void clear();               // 清空容器。
            void reserve(size_t size);   // 将容器的容量设置为至少size。
            void shrink_to_fit();	       // 将容器的容量降到实际大小（需要重新分配内存）。
            void resize(size_t size);    // 把容器的实际大小置为size。
            void resize(size_t size,const T &value);  // 把容器的实际大小置为size，如果size<实际大小，会截断多出的部分；如果size>实际大小，就用value填充。
        元素操作
            T &operator[](size_t n);
            const T &operator[](size_t n) const;  // 只读。
            T &at(size_t n);
            const T &at(size_t n) const;          // 只读。
            T *data();            // 返回容器中动态数组的首地址。
            const T *data() const; // 返回容器中动态数组的首地址。
            T &front();        // 第一个元素。
            const T &front();  // 第一个元素，只读。
            const T &back();  // 最后一个元素，只读。
            T &back();        // 最后一个元素。
        赋值操作
            给已存在的容器赋值，将覆盖容器中原有的内容。
            1）vector &operator=(const vector<T> &v);    // 把容器v赋值给当前容器。
            2）vector &operator=(initializer_list<T> il); // 用统一初始化列表给当前容器赋值。
            3）void assign(initializer_list<T> il);        // 使用统一初始化列表赋值。
            4）void assign(Iterator first, Iterator last);  // 用迭代器赋值。
            5）void assign(const size_t n, const T& value);  // 把n个value给容器赋值。
        交换操作
            void swap(vector<T> &v);    // 把当前容器与v交换。
            交换的是动态数组的地址。
        比较操作
            bool operator == (const vector<T> & v) const;
            bool operator != (const vector<T> & v) const;
        插入和删除
            1）void push_back(const T& value);  // 在容器的尾部追加一个元素。
            2）void emplace_back(…);           // 在容器的尾部追加一个元素，…用于构造元素。C++11
            3）iterator insert(iterator pos, const T& value);  // 在指定位置插入一个元素，返回指向插入元素的迭代器。
            4）iterator emplace (iterator pos, …);  // 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11
            5）iterator insert(iterator pos, iterator first, iterator last);  // 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。
            6）void pop_back();                      // 从容器尾部删除一个元素。
            7）iterator erase(iterator pos);             // 删除指定位置的元素，返回下一个有效的迭代器。
            8）iterator erase(iterator first, iterator last); // 删除指定区间的元素，返回下一个有效的迭代器。
        vector的嵌套
            vector容器可以嵌套使用。
        注意事项
            1）迭代器失效的问题
            resize()、reserve()、assign()、push_back()、pop_back()、insert()、erase()
            等函数会引起vector容器的动态数组发生变化，可能导致vector迭代器失效。

    迭代器(cus_iterator)
        迭代器是访问容器中元素的通用方法。
        如果使用迭代器，不同的容器，访问元素的方法是相同的。
        迭代器支持的基本操作：赋值（=）、解引用（*）、比较（==和!=）、从左向右遍历（++）。
        一般情况下，迭代器是指针和移动指针的方法。
        
        迭代器有五种分类：
            1）正向迭代器（Forward Iterator）
                只能使用++运算符从左向右遍历容器，每次沿容器向右移动一个元素。
                容器名<元素类型>::iterator 迭代器名;        // 正向迭代器。
                容器名<元素类型>::const_iterator 迭代器名;  // 常正向迭代器。
                相关的成员函数：
                    iterator begin();
                    const_iterator begin();
                    const_iterator cbegin();  // 配合auto使用。
                    iterator end();
                    const_iterator end();
                    const_iterator cend();
            2）双向迭代器（Bidirectional Iterator）
                具备正向迭代器的功能，还可以反向（从右到左）遍历容器（也是用++），不管是正向还是反向遍历，都可以用--让迭代器后退一个元素。
                容器名<元素类型>:: reverse_iterator 迭代器名;        // 反向迭代器。
                容器名<元素类型>:: const_reverse_iterator 迭代器名;  // 常反向迭代器。
                相关的成员函数：
                    reverse_iterator rbegin();
                    const_reverse_iterator crbegin();
                    reverse_iterator rend();
                    const_reverse_iterator crend();
            3）随机访问迭代器（Random Access Iterator）
                具备双向迭代器的功能，还支持以下操作：
                用于比较两个迭代器相对位置的关系运算（<、<=、>、>=）。
                迭代器和一个整数值的加减法运算（+、+=、-、-=）。
                支持下标运算（iter[n]）。
                数组的指针是纯天然的随机访问迭代器。
            4）输入迭代器（Input Iterator）
            5）输出迭代器（Output Iterator）
                这两种迭代器比较特殊，它们不是把容器当做操作对象，而是把输入/输出流作为操作对象。

    范围for循环(range_for_loop)
        对于一个有范围的集合来说，在程序代码中指定循环的范围有时候是多余的，还可能犯错误。
        C++11中引入了基于范围的for循环。
        语法：
            for (迭代的变量 : 迭代的范围)
            {
                // 循环体.
            }
        注意：
            1）迭代的范围可以是数组名、容器名、初始化列表或者可迭代的对象（支持begin()、end()、++、==）。
            2）数组名传入函数后，已退化成指针，不能作为容器名。
            3）如果容器中的元素是结构体和类，迭代器变量应该申明为引用，加const约束表示只读。
            4）注意迭代器失效的问题。

    list容器(list_container)
        list容器封装了双链表。
        包含头文件 #include<list>
        list类模板的声明：
            template<class T, class Alloc = allocator<T>>
            class list{
                private:
                    iterator head;
                    iterator tail;
                    ……
            }
        构造函数
            1）list();  // 创建一个空的list容器。
            2）list(initializer_list<T> il); // 使用统一初始化列表。
            3）list(const list<T>& l);  // 拷贝构造函数。
            4）list(Iterator first, Iterator last);  // 用迭代器创建list容器。
            5）list(list<T>&& l);  // 移动构造函数（C++11标准）。
            6）explicit list(const size_t n);   // 创建list容器，元素个数为n。
            7）list(const size_t n, const T& value);  // 创建list容器，元素个数为n，值均为value。
            析构函数~list()释放内存空间。
        特性操作
            size_t max_size() const;     // 返回容器的最大长度，此函数意义不大。
            size_t size() const;        // 返回容器的实际大小（已使用的空间）。
            bool empty() const;      // 判断容器是否为空。
            void clear();             // 清空容器。
            void resize(size_t size);   // 把容器的实际大小置为size。
            void resize(size_t size,const T &value);  // 把容器的实际大小置为size，如果size<实际大小，会截断多出的部分；如果size>实际大小，就用value填充。 
        元素操作
            T &front();        // 第一个元素。
            const T &front();  // 第一个元素，只读。
            const T &back();  // 最后一个元素，只读。
            T &back();        // 最后一个元素。
        赋值操作
            给已存在的容器赋值，将覆盖容器中原有的内容。
            1）list &operator=(const list<T> &l);         // 把容器l赋值给当前容器。
            2）list &operator=(initializer_list<T> il);  // 用统一初始化列表给当前容器赋值。
            3）list assign(initializer_list<T> il);        // 使用统一初始化列表赋值。
            4）list assign(Iterator first, Iterator last);  // 用迭代器赋值。
            5）void assign(const size_t n, const T& value);  // 把n个value给容器赋值。
        交换、反转、排序、归并
            void swap(list<T> &l);   // 把当前容器与l交换，交换的是链表结点的地址。
            void reverse();           // 反转链表。
            void sort();              // 对容器中的元素进行升序排序。
            void sort(_Pr2 _Pred);    // 对容器中的元素进行排序，排序的方法由_Pred决定（二元函数）。
            void merge(list<T> &l);  // 采用归并法合并两个已排序的list容器，合并后的list容器仍是有序的。
        比较操作
            bool operator == (const vector<T> & l) const;
            bool operator != (const vector<T> & l) const;
        插入和删除
            1）void push_back(const T& value);  // 在链表的尾部追加一个元素。
            2）void emplace_back(…);           // 在链表的尾部追加一个元素，…用于构造元素。C++11
            3）iterator insert(iterator pos, const T& value);  // 在指定位置插入一个元素，返回指向插入元素的迭代器。
            4）iterator emplace (iterator pos, …);  // 在指定位置插入一个元素，…用于构造元素，返回指向插入元素的迭代器。C++11
            5）iterator insert(iterator pos, iterator first, iterator last);  // 在指定位置插入一个区间的元素，返回指向第一个插入元素的迭代器。
            6）void pop_back();                      // 从链表尾部删除一个元素。
            7）iterator erase(iterator pos);             // 删除指定位置的元素，返回下一个有效的迭代器。
            8）iterator erase(iterator first, iterator last); // 删除指定区间的元素，返回下一个有效的迭代器。
            9）push_front(const T& value);  // 在链表的头部插入一个元素。
            10）emplace_front(…);          // 在链表的头部插入一个元素，…用于构造元素。C++11
            11）splice(iterator pos, const vector<T> & l);	  // 把另一个链表连接到当前链表。
            12）splice(iterator pos, const vector<T> & l, iterator first, iterator last);	// 把另一个链表指定的区间连接到当前链表。
            13）splice(iterator pos, const vector<T> & l, iterator first);	// 把另一个链表从first开始的结点连接到当前链表。
            14）void remove(const T& value);	 // 删除链表中所有值等于value的元素。
            15）void remove_if(_Pr1 _Pred);    // 删除链表中满足条件的元素，参数_Pred是一元函数。
            16）void unique();                 // 删除链表中相邻的重复元素，只保留一个。
            17）void pop_front();              // 从链表头部删除一个元素。
        
    pair键值对(key_value_pair)
        pair是类模板，一般用于表示key/value数据，其实现是结构体。
        pair结构模板的定义如下：
            template <class T1, class T2>
            struct pair
            {
                T1 first;     // 第一个成员，一般表示key。
                T2 second;  // 第二个成员，一般表示value。
                pair();       // 默认构造函数。
                pair(const T1 &val1,const T2 &val2);   // 有两个参数的构造函数。
                pair(const pair<T1,T2> &p);           // 拷贝构造函数。
                void swap(pair<T1,T2> &p);           // 交换两个pair。
            };
        make_pair函数模板的定义如下：
            template <class T1, class T2>
            make_pair(const T1 &first,const T2 &second)
            {
                return pair<T1,T2>(first, second);
            }
    
    map容器(map_container)
        红黑树
            红黑树的节点数 2ⁿ - 1, n表示红黑树的层数
            2³⁰ - 1 = 1073741824 ≈ 10亿
            所以用红黑树的在10亿的数据集中查找一个数据, 最多只需要查找30次数或比较30次, 效率很高.
        
        在实际开发中, 如果数据量小，用数组加二分查找的效率更高，如果数据量很大，用红黑树更合适.
        
        map 容器封装了红黑树（平衡二叉排序树），用于查找。
        包含头文件： #include<map>
        map容器的元素是pair键值对。
        map类模板的声明：
            template <class K, class V, class P = less<K>, class _Alloc = allocator<pair<const K, V >>>
            class map : public _Tree<_Tmap_traits< K, V, P, _Alloc, false>>
            {
                ...
            }
            解释：
                第一个模板参数K：key的数据类型（pair.first）。
                第二个模板参数V：value的数据类型（pair.second）。
                第三个模板参数P：排序方法，缺省按key升序。
                第四个模板参数_Alloc：分配器，缺省用new和delete。
        map提供了双向迭代器。

        二叉链表：                               
            struct BTNode                        
            {                                  
                pair<K,V> p;       // 键值对。      
                BTNode *parent;   // 父节点。   
                BTNode *lchirld;    // 左子树。
                BTNode *rchild;    // 右子树。
            };                                      
        构造函数
            1）map();  // 创建一个空的map容器。
            2）map(initializer_list<pair<K,V>> il); // 使用统一初始化列表。
            3）map(const map<K,V>& m);  // 拷贝构造函数。
            4）map(Iterator first, Iterator last);  // 用迭代器创建map容器。
            5）map(map<K,V>&& m);  // 移动构造函数（C++11标准）。
        特性操作
            size_t size() const;        // 返回容器的实际大小（已使用的空间）。
            bool empty() const;      // 判断容器是否为空。
            void clear();             // 清空容器。
        元素操作
            V &operator[](K key);             // 用给定的key访问元素。
            const V &operator[](K key) const;  // 用给定的key访问元素，只读。
            V &at(K key);                     // 用给定的key访问元素。
            const V &at(K key) const;         // 用给定的key访问元素，只读。
            注意：
                1）[ ]运算符：如果指定键不存在，会向容器中添加新的键值对；如果指定键不存在，则读取或修改容器中指定键的值。
                2）at()成员函数：如果指定键不存在，不会向容器中添加新的键值对，而是直接抛出out_of_range 异常。
        赋值操作
            给已存在的容器赋值，将覆盖容器中原有的内容。
            1）map<K,V> &operator=(const map<K,V>& m);         // 把容器m赋值给当前容器。
            2）map<K,V> &operator=(initializer_list<pair<K,V>> il);  // 用统一初始化列表给当前容器赋值。
        交换操作
            void swap(map<K,V>& m);    // 把当前容器与m交换。
            交换的是树的根结点。
        比较操作
            bool operator == (const map<K,V>& m) const;
            bool operator != (const map<K,V>& m) const;
        查找操作
            1）查找键值为key的键值对
                在map容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。
                iterator find(const K &key);
                const_iterator find(const K &key) const;  // 只读。
            2）查找键值>=key的键值对
                在map容器中查找第一个键值>=key的键值对，成功返回迭代器；失败返回end()。
                iterator lower_bound(const K &key);
                const_iterator lower_bound(const K &key) const;  // 只读。
            3）查找键>key的键值对
                在map容器中查找第一个键值>key的键值对，成功返回迭代器；失败返回end()。
                iterator upper_bound(const K &key);
                const_iterator upper_bound(const K &key) const;  // 只读。
            4）统计键值对的个数
                统计map容器中键值为key的键值对的个数。
                size_t count(const K &key) const;
        插入和删除
            1）void insert(initializer_list<pair<K,V>> il);  // 用统一初始化列表在容器中插入多个元素。
            2）pair<iterator,bool> insert(const pair<K,V> &value);  // 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。
            3）void insert(iterator first,iterator last);  // 用迭代器插入一个区间的元素。
            4）pair<iterator,bool> emplace (...);  // 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。
            5）iterator emplace_hint (const_iterator pos,...); // 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义，如果提示的位置是正确的，对性能有提升，如果提示的位置不正确，性能反而略有下降，但是，插入是否成功与该参数元关。该参数常用end()和begin()。成功返回新插入元素的迭代器；如果元素已经存在，则插入失败，返回现有元素的迭代器。
            6）size_t erase(const K & key);  // 从容器中删除指定key的元素，返回已删除元素的个数。
            7）iterator erase(iterator pos);  // 用迭代器删除元素，返回下一个有效的迭代器。
            8）iterator erase(iterator first,iterator last);  // 用迭代器删除一个区间的元素，返回下一个有效的迭代器。
        分段构造
            详见分段构造
            例：m5.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple("冰冰", 18));
            
    unordered_map容器(unordered_map_container)
        哈希表/散列表
            哈希表长：数组长度
            哈希函数：size_t hash(const T &key) {...
                key%小于哈希表的最大质数.
                哈希函数的返回值必须小于哈希表的表长
            装填因子：哈希表中元素的总数/表长，其值越大，效率越低.

        在实际开发中，如果数据量只有几万，用红黑树也可以，如果数据量达到了上千万，必须用哈希表
        
        unordered_map容器封装了哈希表，查找、插入和删除元素时，只需要比较几次key的值。
        包含头文件 #include<unordered_map>
        unordered_map容器的元素是pair键值对。
        unordered_map类模板的声明：
            template <class K, class V, class _Hasher = hash<K>, class _Keyeq = equal_to<K>,
            class _Alloc = allocator<pair<const K, V>>>
            class unordered_map : public _Hash<_Umap_traits<K, V, _Uhash_compare<K, _Hasher, _Keyeq>, _Alloc, false>>
            {
                ...
            }
        
        第一个模板参数K：key的数据类型（pair.first）。
        第二个模板参数V：value的数据类型（pair.second）。
        第三个模板参数_Hasher：哈希函数，默认值为std::hash<K>
        第四个模板参数_Keyeq：比较函数，用于判断两个key是否相等，默认值是std::equal_to<K>。
        第五个模板参数_Alloc：分配器，缺省用new和delete。
        创建std::unordered_map类模板的别名：
            template<class K,class V>
            using umap = std::unordered_map<K, V>;

        构造函数
            1）umap();  // 创建一个空的umap容器。
            2）umap(size_t bucket);  // 创建一个空的umap容器，指定了桶的个数，下同。
            3）umap(initializer_list<pair<K,V>> il); // 使用统一初始化列表。
            4）umap(initializer_list<pair<K,V>> il, size_t bucket); // 使用统一初始化列表。
            5）umap(Iterator first, Iterator last);  // 用迭代器创建umap容器。
            6）umap(Iterator first, Iterator last, size_t bucket);  // 用迭代器创建umap容器。
            7）umap(const umap<K,V>& m);  // 拷贝构造函数。
            8）umap(umap<K,V>&& m);  // 移动构造函数（C++11标准）。
        特性操作
            1）size_t size() const;        // 返回容器中元素的个数。
            2）bool empty() const;      // 判断容器是否为空。
            3）void clear();             // 清空容器。
            4）size_t max_bucket_count();     // 返回容器底层最多可以使用多少桶，无意义。
            5）size_t bucket_count();          // 返回容器桶的数量，空容器有8个桶。
            6）float load_factor();   // 返回容器当前的装填因子，load_factor() = size() / bucket_count()。
            7）float max_load_factor();        // 返回容器的最大装填因子，达到该值后，容器将扩充，缺省为1。
            8）void max_load_factor (float z ); // 设置容器的最大装填因子。
            9）iterator begin(size_t n);        // 返回第n个桶中第一个元素的迭代器。
            10）iterator end(size_t n);          // 返回第n个桶中最后一个元素尾后的迭代器。
            11）void reserve(size_t n);          // 将容器设置为至少n个桶。
            12）void rehash(size_t n);           // 将桶的数量调整为>=n。如果n大于当前容器的桶数，该方法会将容器重新哈希；如果n的值小于当前容器的桶数，该方法可能没有任何作用。
            13）size_t bucket_size(size_t n);     // 返回第n个桶中元素的个数，0 <= n < bucket_count()。
            14）size_t bucket(K &key);          // 返回值为key的元素对应的桶的编号。
        元素操作
            V &operator[](K key);             // 用给定的key访问元素。
            const V &operator[](K key) const;  // 用给定的key访问元素，只读。
            V &at(K key);                     // 用给定的key访问元素。
            const V &at(K key) const;         // 用给定的key访问元素，只读。
            注意：
                1）[ ]运算符：如果指定键不存在，会向容器中添加新的键值对；如果指定键不存在，则读取或修改容器中指定键的值。
                2）at()成员函数：如果指定键不存在，不会向容器中添加新的键值对，而是直接抛出out_of_range 异常。
        赋值操作
            给已存在的容器赋值，将覆盖容器中原有的内容。
            1）umap<K,V> &operator=(const umap<K,V>& m);       // 把容器m赋值给当前容器。
            2）umap<K,V> &operator=(initializer_list<pair<K,V>> il);  // 用统一初始化列表给容器赋值。
        交换操作
            void swap(umap<K,V>& m);    // 把当前容器与m交换。
            交换的是树的根结点。
        比较操作
            bool operator == (const umap<K,V>& m) const;
            bool operator != (const umap<K,V>& m) const;
        查找操作
            1）查找键值为key的键值对
                在umap容器中查找键值为key的键值对，如果成功找到，则返回指向该键值对的迭代器；失败返回end()。
                iterator find(const K &key);
                const_iterator find(const K &key) const;  // 只读。
            2）统计键值对的个数
                统计umap容器中键值为key的键值对的个数。
                size_t count(const K &key) const;
        插入和删除
            1）void insert(initializer_list<pair<K,V>> il);  // 用统一初始化列表在容器中插入多个元素。
            2）pair<iterator,bool> insert(const pair<K,V> &value);  // 在容器中插入一个元素，返回值pair：first是已插入元素的迭代器，second是插入结果。
            3）void insert(iterator first,iterator last);  // 用迭代器插入一个区间的元素。
            4）pair<iterator,bool> emplace (...);  // 将创建新键值对所需的数据作为参数直接传入，map容器将直接构造元素。返回值pair：first是已插入元素的迭代器，second是插入结果。
            例：mm.emplace(piecewise_construct, forward_as_tuple(8), forward_as_tuple("冰冰", 18));
            5）iterator emplace_hint (const_iterator pos,...); // 功能与第4）个函数相同，第一个参数提示插入位置，该参数只有参考意义。对哈希容器来说，此函数意义不大。
            6）size_t erase(const K & key);  // 从容器中删除指定key的元素，返回已删除元素的个数。
            7）iterator erase(iterator pos);  // 用迭代器删除元素，返回下一个有效的迭代器。
            8）iterator erase(iterator first,iterator last);  // 用迭代器删除一个区间的元素，返回下一个有效的迭代器。
        
    queue容器(queue_container)
        queue容器的逻辑结构是队列，物理结构可以是数组或链表，主要用于多线程之间的数据共享。
        包含头文件 #include<queue>
        queue类模板的声明：
            template <class T, class _Container = deque<T>>
            class queue{
                ……
            }
        第一个模板参数T：元素的数据类型。
        第二个模板参数_Container：底层容器的类型，缺省是std::deque，可以用std::list，还可以用自定义的类模板。
        queue容器不支持迭代器。
        
        构造函数
            1）queue();  // 创建一个空的队列。
            2）queue(const queue<T>& q);  // 拷贝构造函数。
            3）queue(queue<T>&& q);  // 移动构造函数（C++11标准）。
            析构函数~queue()释放内存空间。
        常用操作
            1）void push(const T& value);  // 元素入队。
            2）void emplace(…);           // 元素入队，…用于构造元素。C++11
            3）size_t size() const;          // 返回队列中元素的个数。
            4）bool empty() const;        // 判断队列是否为空。
            5）T &front();                 // 返回队头元素。
            6）const T &front();           // 返回队头元素，只读。
            7）T &back();                 // 返回队尾元素。
            8）const T &back();           // 返回队头元素，只读。
            9）void pop();                // 出队，删除队头的元素。
        其它操作
            1）queue &operator=(const queue<T> &q);    // 赋值。
            2）void swap(queue<T> &q);    // 交换。
            3）bool operator == (const queue<T> & q) const; // 重载==操作符。
            4）bool operator != (const queue<T> & q) const; // 重载!=操作符。
        
    STL其它容器(stl_other_container)
        数据结构有数组，链表，二叉树和哈希表。stl的所有容器都是基于这些数据结构实现的。

        array（静态数组）
            1）物理结构
            在栈上分配内存，创建数组的时候，数组长度必须是常量，创建后的数组大小不可变。
                template<class T, size_t size>
                class array{
                private:
                T elems_[size];
                ……
                };
            2）迭代器
                随机访问迭代器。
            3）特点
                部分场景中，比常规数组更方便（能用于模板），可以代替常规数组。
            4）各种操作
                1）void fill(const T & val);     // 给数组填充值（清零）。
                2）size_t size();               // 返回数组的大小。
                3）bool empty() const;        // 无意义。
                4）T &operator[](size_t n);
                5）const T &operator[](size_t n) const;  // 只读。
                6）T &at(size_t n);
                7）const T &at(size_t n) const;          // 只读。
                8）T *data();            // 返回数组的首地址。
                9）const T *data() const; // 返回数组的首地址。
                10）T &front();          // 第一个元素。
                11）const T &front();    // 第一个元素，只读。
                12）const T &back();    // 最后一个元素，只读。
                13）T &back();        // 最后一个元素。
        deque（双端队列）
            1）物理结构
                deque容器存储数据的空间是多段等长的连续空间构成，各段空间之间并不一定是连续的。
                为了管理这些连续空间的分段，deque容器用一个数组存放着各分段的首地址。
                通过建立数组，deque容器的分段的连续空间能实现整体连续的效果。
                当deque容器在头部或尾部增加元素时，会申请一段新的连续空间，同时在数组中添加指向该空间的指针。
            2）迭代器
                随机访问迭代器。
            3）特点
                提高了在两端插入和删除元素的效率，扩展空间的时候，不需要拷贝以前的元素。
                在中间插入和删除元素的效率比vector更糟糕。
                随机访问的效率比vector容器略低。
            4）各种操作
                与vector容器相同。
        forward_list（单链表）
            1）物理结构
                单链表。
            2）迭代器
                正向迭代器。
            3）特点
                比双链表少了一个指针，可节省一丢丢内存，减少了两次对指针的赋值操作。
                如果单链表能满足业务需求，建议使用单链表而不是双链表。
            4）各种操作
                与list容器相同。
        multimap
            底层是红黑树。
            multimap和map的区别在：multimap允许关键字重复，而map不允许重复。
            各种操作与map容器相同。
        set&multiset
            底层是红黑树。
            set和map的区别在：map中存储的是键值对，而set只保存关键字。
            multiset和set的区别在：multiset允许关键字重复，而set不允许重复。
            各种操作与map容器相同。
        unordered_multimap
            底层是哈希表。
            unordered_multimap和unordered_map的区别在：unordered_multimap允许关键字重复，而unordered_map不允许重复。
            各种操作与unordered_map容器相同。
        unordered_set&unordered_multiset
            底层是哈希表。
            unordered_set和unordered_map的区别在：unordered_map中存储的是键值对，而unordered_set只保存关键字。
            unordered_multiset和unordered_set的区别在：unordered_multiset允许关键字重复，而unordered_set不允许重复。
            各种操作与unordered_map容器相同。
        priority_queue（优先队列）
            优先级队列相当于一个有权值的单向队列queue，在这个队列中，所有元素是按照优先级排列的。
            底层容器可以用deque和list。
            各种操作与queue容器相同。
        stack（栈）
            底层容器可以用deque和list。
    
    STL算法(stl_algorithm)
        stl算法就是一些常用的函数模板。
        stl算法实现了很多通用的功能，可以拿来即用。
        建议复习（函数指针和回调函数）和（重载括号运算符）
        
        STL提供了很多处理容器的函数模板，它们的设计是相同的，有以下特点：
            1）用迭代器表示需要处理数据的区间。
            2）返回迭代器放置处理数据的结果（如果有结果）。
            3）接受一个函数对象参数（结构体模板），用于处理数据（如果需要）。
        函数对象
            很多STL算法都使用函数对象，也叫函数符（functor），包括函数名、函数指针和仿函数。
            函数符的概念：
                1）生成器（generator）：不用参数就可以调用的函数符。
                2）一元函数（unary function）：用一个参数可以调用的函数符。
                3）二元函数（binary function）：用两个参数可以调用的函数符。
            改进的概念：
                1）一元谓词（predicate）：返回bool值的一元函数。
                2）二元谓词（binary predicate）：返回bool值的二元函数。
        预定义的函数对象
            STL定义了多个基本的函数符，用于支持STL的算法函数。
            包含头文件：#include <functional>
            详见可见文档
        算法函数
            STL将算法函数分成四组：
                1）非修改式序列操作：对区间中的每个元素进行操作，这些操作不修改容器的内容。
                2）修改式序列操作：对区间中的每个元素进行操作，这些操作可以容器的内容（可以修改值，也可以修改排列顺序）。
                3）排序和相关操作：包括多个排序函数和其它各种函数，如集合操作。
                4）通用数字运算：包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。通常，这些都是数组的操作特性，因此vector是最有可能使用这些操作的容器。
            前三组在头文件#include <algorithm>中，第四组专用于数值数据，在#include <numeric>中。
            详见《C++ Primer plus》，第六版，从886页开始。
        学习要领
            1）如果容器有成员函数，则使用成员函数，如果没有才考虑用STL的算法函数。
            2）把全部的STL算法函数过一遍，知道大概有些什么东西。
            3）如果打算采用某算法函数，一定要搞清楚它的原理，关注它的效率。
            4）不要太看重这些算法函数，自己写一个也就那么回事。
        常用函数
            1）for_each()遍历
            2）find()遍历
            3）find_if()遍历
            4）find_not_if()遍历
            5）sort()排序
                STL的sort算法，数据量大时采用QuickSort(快速排序)，分段归并排序。一旦分段后的数据量小于某个门槛（16），为避免QuickSort的递归调用带来过大的额外负荷，就改用InsertSort（插入排序）。如果递归层次过深，还会改用HeapSort（堆排序）。
                适用于数组容器vector、string、deque（list容器有sort成员函数，红黑树和哈希表没有排序的说法）。
            6）二分查找
                lower_bound()
                upper_bound()
                equal_range()
                binary_search()












贰零.智能指针(020SmartPointer)

    智能指针解释：
        手动指针：堆区的内存一定要手动释放，否则会发生内存的泄漏
            new和new[]的内存需要用delete和deletet[]释放
            程序员的主观失误, 忘了或漏了释放.
                这种情况高级开发者也难免会出现这种失误，和水平没有关系，只是难免会在复杂的代码逻辑中顾全。
            程序员也不确定什么时候释放
                比如多个线程共享一个对象的时候，就没办法确定什么时候释放内存。
        普通指针的释放：
            类内的指针，在析构函数中释放。
                通常类里面的指针，会把释放资源的代码放到析构函数中，对象过期时，系统会自动调用析构，释放资源
            Cpp内置的数据类型，必须手动的delete。
            new出来的类，还是要手动写delete。
        智能指针的设计思路（智能指针的目的就是解决资源释放的问题）
            智能指针是类模板，在栈上创建智能指针对象
            把普通指针交给智能指针对象
            智能指针对象过期时，系统会自动调用智能指针对象的析构函数，释放普通指针的内存。
        cpp的智能指针类型：
            auto_ptr 是 cpp98标准，c17已弃用
            unique_ptr,shared_ptr,weak_ptr 是 Cpp11标准

    智能指针unique_ptr(smart_pointer_unique_ptr)
        unique_ptr独享它指向的对象，也就是说，同时只有一个unique_ptr指向同一个对象，当这个unique_ptr被销毁时，指向的对象也随即被销毁。
        包含头文件：#include <memory>
            template <typename T, typename D = default_delete<T>>
            class unique_ptr
            {
                public:
                    explicit unique_ptr(pointer p) noexcept;	// 不可用于转换函数。
                    ~unique_ptr() noexcept;    
                    T& operator*() const;            // 重载*操作符。
                    T* operator->() const noexcept;  // 重载->操作符。
                    unique_ptr(const unique_ptr &) = delete;   // 禁用拷贝构造函数。
                    unique_ptr& operator=(const unique_ptr &) = delete;  // 禁用赋值函数。
                    unique_ptr(unique_ptr &&) noexcept;	  // 右值引用。
                    unique_ptr& operator=(unique_ptr &&) noexcept;  // 右值引用。
                    // ...
                    private:
                    pointer ptr;  // 内置的指针。
            };
        第一个模板参数T：指针指向的数据类型。
        第二个模板参数D：指定删除器，缺省用delete释放资源。
        测试类AA的定义：
            class AA
            {
                public:
                    string m_name;
                    AA() { cout << m_name << "调用构造函数AA()。\n"; }
                    AA(const string & name) : m_name(name) { cout << "调用构造函数AA("<< m_name << ")。\n"; }
                    ~AA() { cout << m_name << "调用了析构函数~AA(" << m_name << ")。\n"; }
            };
        基本用法
            1）初始化
                方法一：
                    unique_ptr<AA> p0(new AA("西施"));     // 分配内存并初始化。
                方法二：
                    unique_ptr<AA> p0 = make_unique<AA>("西施");   // C++14标准。
                    unique_ptr<int> pp1=make_unique<int>();         // 数据类型为int。
                    unique_ptr<AA> pp2 = make_unique<AA>();       // 数据类型为AA，默认构造函数。
                    unique_ptr<AA> pp3 = make_unique<AA>("西施");  // 数据类型为AA，一个参数的构造函数。
                    unique_ptr<AA> pp4 = make_unique<AA>("西施",8); // 数据类型为AA，两个参数的构造函数。
                方法三（不推荐）：
                    AA* p = new AA("西施");
                    unique_ptr<AA> p0(p);                  // 用已存在的地址初始化。
            2）使用方法
                智能指针重载了*和->操作符，可以像使用指针一样使用unique_ptr。
                不支持普通的拷贝和赋值。
                    AA* p = new AA("西施");
                    unique_ptr<AA> pu2 = p;              // 错误，不能把普通指针直接赋给智能指针。
                    unique_ptr<AA> pu3 = new AA("西施"); // 错误，不能把普通指针直接赋给智能指针。
                    unique_ptr<AA> pu2 = pu1;           // 错误，不能用其它unique_ptr拷贝构造。
                    unique_ptr<AA> pu3;
                    pu3 = pu1;                            // 错误，不能用=对unique_ptr进行赋值。
                不要用同一个裸指针初始化多个unique_ptr对象。
                get()方法返回裸指针。
                不要用unique_ptr管理不是new分配的内存。
            3）用于函数的参数
                传引用（不能传值，因为unique_ptr没有拷贝构造函数）。
                裸指针。
            4）不支持指针的运算（+、-、++、--）
        更多技巧
            1）将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器禁止这样做。一般用于函数的返回值。
                unique_ptr<AA> p0;
                p0 = unique_ptr<AA>(new AA ("西瓜"));
            2）用nullptr给unique_ptr赋值将释放对象，空的unique_ptr==nullptr。
            3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。（可用于把unique_ptr传递给子函数，子函数将负责释放对象）
            4）std::move()可以转移对原始指针的控制权。（可用于把unique_ptr传递给子函数，子函数形参也是unique_ptr）
            5）reset()释放对象。
                void reset(T * _ptr= (T *) nullptr);
                pp.reset();        // 释放pp对象指向的资源对象。
                pp.reset(nullptr);  // 释放pp对象指向的资源对象
                pp.reset(new AA("bbb"));  // 释放pp指向的资源对象，同时指向新的对象。
            6）swap()交换两个unique_ptr的控制权。
                void swap(unique_ptr<T> &_Right);
            7）unique_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。
            8）unique_ptr不是绝对安全，如果程序中调用exit()退出，全局的unique_ptr可以自动释放，但局部的unique_ptr无法释放。
            9）unique_ptr提供了支持数组的具体化版本。
                数组版本的unique_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。
                // unique_ptr<int[]> parr1(new int[3]);          // 不指定初始值。
                unique_ptr<int[]> parr1(new int[3]{ 33,22,11 });  // 指定初始值。
                cout << "parr1[0]=" << parr1[0] << endl;
                cout << "parr1[1]=" << parr1[1] << endl;
                cout << "parr1[2]=" << parr1[2] << endl;
                
                unique_ptr<AA[]> parr2(new AA[3]{string("西施"), string("冰冰"), string("幂幂")});
                cout << "parr2[0].m_name=" << parr2[0].m_name << endl;
                cout << "parr2[1].m_name=" << parr2[1].m_name << endl;
                cout << "parr2[2].m_name=" << parr2[2].m_name << endl;
            
    智能指针shared_ptr(smart_pointer_shared_ptr)
        shared_ptr共享它指向的对象，多个shared_ptr可以指向（关联）相同的对象，在内部采用计数机制来实现。
        当新的shared_ptr与对象关联时，引用计数增加1。
        当shared_ptr超出作用域时，引用计数减1。当引用计数变为0时，则表示没有任何shared_ptr与对象关联，则释放该对象。
        基本用法
            shared_ptr的构造函数也是explicit，但是，没有删除拷贝构造函数和赋值函数。
            1）初始化
                方法一：
                    shared_ptr<AA> p0(new AA("西施"));     // 分配内存并初始化。
                方法二：
                    shared_ptr<AA> p0 = make_shared<AA>("西施");  // C++11标准，效率更高。
                    shared_ptr<int> pp1=make_shared<int>();         // 数据类型为int。
                    shared_ptr<AA> pp2 = make_shared<AA>();       // 数据类型为AA，默认构造函数。
                    shared_ptr<AA> pp3 = make_shared<AA>("西施");  // 数据类型为AA，一个参数的构造函数。
                    shared_ptr<AA> pp4 = make_shared<AA>("西施",8); // 数据类型为AA，两个参数的构造函数。
                方法三：
                    AA* p = new AA("西施");
                    shared_ptr<AA> p0(p);                  // 用已存在的地址初始化。
                方法四：
                    shared_ptr<AA> p0(new AA("西施"));
                    shared_ptr<AA> p1(p0);                 // 用已存在的shared_ptr初始化，计数加1。
                    shared_ptr<AA> p1=p0;                 // 用已存在的shared_ptr初始化，计数加1。
            2）使用方法
                智能指针重载了*和->操作符，可以像使用指针一样使用shared_ptr。
                use_count()方法返回引用计数器的值。
                unique()方法，如果use_count()为1，返回true，否则返回false。
                shared_ptr支持赋值，左值的shared_ptr的计数器将减1，右值shared_ptr的计算器将加1。
                get()方法返回裸指针。
                不要用同一个裸指针初始化多个shared_ptr。
                不要用shared_ptr管理不是new分配的内存。
            3）用于函数的参数
                与unique_ptr的原理相同。
            4）不支持指针的运算（+、-、++、--）
        二、更多细节
            1）将一个unique_ptr赋给另一个时，如果源unique_ptr是一个临时右值，编译器允许这样做；如果源unique_ptr将存在一段时间，编译器禁止这样做。一般用于函数的返回值。
            2）用nullptr给shared_ptr赋值将把计数减1，如果计数为0，将释放对象，空的shared_ptr==nullptr。
            3）release()释放对原始指针的控制权，将unique_ptr置为空，返回裸指针。
            4）std::move()可以转移对原始指针的控制权。还可以将unique_ptr转移成shared_ptr。
            5）reset()改变与资源的关联关系。
                pp.reset();        // 解除与资源的关系，资源的引用计数减1。
                pp. reset(new AA("bbb"));  // 解除与资源的关系，资源的引用计数减1。关联新资源。
            6）swap()交换两个shared_ptr的控制权。
                void swap(shared_ptr<T> &_Right);
            7）shared_ptr也可象普通指针那样，当指向一个类继承体系的基类对象时，也具有多态性质，如同使用裸指针管理基类对象和派生类对象那样。
            8）shared_ptr不是绝对安全，如果程序中调用exit()退出，全局的shared_ptr可以自动释放，但局部的shared_ptr无法释放。
            9）shared_ptr提供了支持数组的具体化版本。
                数组版本的shared_ptr，重载了操作符[]，操作符[]返回的是引用，可以作为左值使用。
            10）shared_ptr的线程安全性：
                shared_ptr的引用计数本身是线程安全（引用计数是原子操作）。
                多个线程同时读同一个shared_ptr对象是线程安全的。
                如果是多个线程对同一个shared_ptr对象进行读和写，则需要加锁。
                多线程读写shared_ptr所指向的同一个对象，不管是相同的shared_ptr对象，还是不同的shared_ptr对象，也需要加锁保护。
            11）如果unique_ptr能解决问题，就不要用shared_ptr。unique_ptr的效率更高，占用的资源更少。
            
    智能指针的删除器(smart_pointer_remover)
        在默认情况下，智能指针过期的时候，用delete原始指针; 释放它管理的资源。
        程序员可以自定义删除器，改变智能指针释放资源的行为。
        删除器可以是全局函数、仿函数和Lambda表达式，形参为原始指针。
        
    智能指针weak_ptr(smart_pointer_weak_ptr)
        shared_ptr存在的问题
            shared_ptr内部维护了一个共享的引用计数器，多个shared_ptr可以指向同一个资源。
            如果出现了循环引用的情况，引用计数永远无法归0，资源不会被释放。
        weak_ptr是什么
            weak_ptr 是为了配合shared_ptr而引入的，它指向一个由shared_ptr管理的资源但不影响资源的生命周期。也就是说，将一个weak_ptr绑定到一个shared_ptr不会改变shared_ptr的引用计数。
            不论是否有weak_ptr指向，如果最后一个指向资源的shared_ptr被销毁，资源就会被释放。
            weak_ptr更像是shared_ptr的助手, 而不是智能指针。
        如何使用weak_ptr
            weak_ptr没有重载 ->和 *操作符，不能直接访问资源。
            有以下成员函数：
                1）operator=();  // 把shared_ptr或weak_ptr赋值给weak_ptr。
                2）expired();     // 判断它指资源是否已过期（已经被销毁）。
                3）lock();        // 返回shared_ptr，如果资源已过期，返回空的shared_ptr。
                4）reset();       // 将当前weak_ptr指针置为空。
                5）swap();       // 交换。
            weak_ptr不控制对象的生命周期，但是，它知道对象是否还活着。
            用lock()函数把它可以提升为shared_ptr，如果对象还活着，返回有效的shared_ptr，如果对象已经死了，提升会失败，返回一个空的shared_ptr。
            提升的行为（lock()）是线程安全的。












贰壹.Cpp文件操作(021CppFileOperate)
    
    写入文本文件(write_text_file)
        文本文件一般以行的形式组织数据。
        包含头文件：#include <fstream>
        类：ofstream（output file stream）
        ofstream打开文件的模式（方式）：
        对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。
            ios::out     		缺省值：会截断文件内容。
            ios::trunc  		截断文件内容，即覆盖文件内容。（truncate）
            ios::app   		不截断文件内容，只在文件未尾追加文件。（append）
        
    读取文本文件(read_text_file)
        包含头文件：#include <fstream>
        类：ifstream
        ifstream打开文件的模式（方式）：
        对于ifstream，如果文件不存在，则打开文件失败。
            ios::in     		缺省值。

    写入二进制文件(write_binary_file)
        二进制文件以数据块的形式组织数据，把内存中的数据直接写入文件。
        包含头文件：#include <fstream>
        类：ofstream（output file stream）
        ofstream打开文件的模式（方式）：
        对于ofstream，不管用哪种模式打开文件，如果文件不存在，都会创建文件。
            ios::out     		缺省值：会截断文件内容。
            ios::trunc  		截断文件内容。（truncate）
            ios::app   		不截断文件内容，只在文件未尾追加文件。（append）
            ios::binary   	以二进制方式打开文件。
        操作文本文件和二进制文件的一些细节：
            1）在windows平台下，文本文件的换行标志是"\r\n"。
            2）在linux平台下，文本文件的换行标志是"\n"。
            3）在windows平台下，如果以文本方式打开文件，写入数据的时候，系统会将"\n"转换成"\r\n"；读取数据的时候，系统会将"\r\n"转换成"\n"。 如果以二进制方式打开文件，写和读都不会进行转换。
            4）在Linux平台下，以文本或二进制方式打开文件，系统不会做任何转换。
            5）以文本方式读取文件的时候，遇到换行符停止，读入的内容中没有换行符；以二制方式读取文件的时候，遇到换行符不会停止，读入的内容中会包含换行符（换行符被视为数据）。
            6）在实际开发中，从兼容和语义考虑，一般：
                a）以文本模式打开文本文件，用行的方法操作它；
                b）以二进制模式打开二进制文件，用数据块的方法操作它；
                c）以二进制模式打开文本文件和二进制文件，用数据块的方法操作它，这种情况表示不关心数据的内容。（例如复制文件和传输文件）
                d）不要以文本模式打开二进制文件，也不要用行的方法操作二进制文件，可能会破坏二进制数据文件的格式，也没有必要。（因为二进制文件中的某字节的取值可能是换行符，但它的意义并不是换行，可能是整数n个字节中的某个字节）
    
    读取二进制文件(read_binary_file)
        

        包含头文件：#include <fstream>
        类：ifstream
        ifstream打开文件的模式（方式）：
        对于ifstream，如果文件不存在，则打开文件失败。
            ios::in     		缺省值。
            ios::binary   	以二进制方式打开文件。
        
    随机存取(random_access)
        fstream类
            fstream类既可以读文本/二进制文件，也可以写文本/二进制文件。
            fstream类的缺省模式是ios::in | ios::out，如果文件不存在，则创建文件；但是，不会清空文件原有的内容。
            普遍的做法是：
                1）如果只想写入数据，用ofstream；如果只想读取数据，用ifstream；如果想写和读数据，用fstream，这种情况不多见。不同的类体现不同的语义。
                2）在Linux平台下，文件的写和读有严格的权限控制。（需要的权限越少越好）
        文件的位置指针
            对文件进行读/写操作时，文件的位置指针指向当前文件读/写的位置。
            很多资料用“文件读指针的位置”和“文件写指针的位置”，容易误导人。不管用哪个类操作文件，文件的位置指针只有一个。
            1）获取文件位置指针
                ofstream类的成员函数是tellp()；ifstream类的成员函数是tellg()；fstream类两个都有，效果相同。
                    std::streampos tellp();
                    std::streampos tellg();
            2）移动文件位置指针
                ofstream类的函数是seekp()；ifstream类的函数是seekg()；fstream类两个都有，效果相同。
                方法一：
                    std::istream & seekg(std::streampos _Pos);  
                    fin.seekg(128);   // 把文件指针移到第128字节。
                    fin.seekp(128);   // 把文件指针移到第128字节。
                    fin.seekg(ios::beg) // 把文件指针移动文件的开始。
                    fin.seekp(ios::end) // 把文件指针移动文件的结尾。
                方法二：
                    std::istream & seekg(std::streamoff _Off,std::ios::seekdir _Way);
                    在ios中定义的枚举类型：
                    enum seek_dir {beg, cur, end};  // beg-文件的起始位置；cur-文件的当前位置；end-文件的结尾位置。
                    fin.seekg(30, ios::beg);    // 从文件开始的位置往后移30字节。
                    fin.seekg(-5, ios::cur);     // 从当前位置往前移5字节。
                    fin.seekg( 8, ios::cur);     // 从当前位置往后移8字节。
                    fin.seekg(-10, ios::end);   // 从文件结尾的位置往前移10字节。
        随机存取
            随机存取是指直接移动文件的位置指针，在指定位置读取/写入数据。
            打开文件的模式，如果文件不存在，各种模式都会创建文件。
                ios::out     		1）会截断文件；2）可以用seekp()移动文件指针。
                ios:trunc  		1）会截断文件；2）可以用seekp()移动文件指针。
                ios::app   		1）不会截断文件；2）文件指针始终在文件未尾，不能用seekp()移动文件指针。
                ios::ate    		打开文件时文件指针指向文件末尾，但是，可以在文件中的任何地方写数据。
                ios::in        		打开文件进行读操作，即读取文件中的数据。
                ios::binary       	打开文件为二进制文件，否则为文本文件。
            注：ate是at end的缩写，trunc是truncate（截断）的缩写，app是append（追加）的缩写。
            
    文件缓冲区和流状态(file_buffer_and_stream_status)
        文件缓冲区
            文件缓冲区（文件缓存）是系统预留的内存空间，用于存放输入或输出的数据。
            根据输出和输入流，分为输出缓冲区和输入缓冲区。
            注意，在C++中，每打开一个文件，系统就会为它分配缓冲区。不同的流，缓冲区是独立的。
            程序员不用关心输入缓冲区，只关心输出缓冲区就行了。
            在缺省模式下，输出缓冲区中的数据满了才把数据写入磁盘，但是，这种模式不一定能满足业务的需求。
            输出缓冲区的操作：
                1）flush()成员函数
                    刷新缓冲区，把缓冲区中的内容写入磁盘文件。
                2）endl
                    换行，然后刷新缓冲区。
                3）unitbuf
                    fout << unitbuf;
                    设置fout输出流，在每次操作之后自动刷新缓冲区。
                4）nounitbuf
                    fout << nounitbuf;
                    设置fout输出流，让fout回到缺省的缓冲方式。
        流状态
            流状态有三个：eofbit、badbit和failbit，取值：1-设置；或0-清除。
            当三个流状成都为0时，表示一切顺利，good()成员函数返回true。
            一般判断状态最常用的就是 eof() 和 good() 两个函数。
                1）eofbit
                    当输入流操作到达文件未尾时，将设置eofbit。
                    eof()成员函数检查流是否设置了eofbit。
                2）badbit
                    无法诊断的失败破坏流时，将设置badbit。（例如：对输入流进行写入；磁盘没有剩余空间）。
                    bad()成员函数检查流是否设置了badbit。
                3）failbit
                    当输入流操作未能读取预期的字符时，将设置failbit（非致命错误，可挽回，一般是软件错误，例如：想读取一个整数，但内容是一个字符串；文件到了未尾）I/O失败也可能设置failbit。
                    fail()成员函数检查流是否设置了failbit。
                4）clear()成员函数清理流状态。
                5）setstate()成员函数重置流状态。
            
    
    








贰贰.Cpp异常和断言(022CppExceptionAndAssertion)

    异常的理念看似有前景，但实际的使用效果并不好。
    编程社区达成的一致意见是，最好不要使用这项功能。
    c++98引入异常规范，但在c++11中已经弃用
    异常的知识没什么用，但是不学又不行，因为过去的一些老项目会有异常的使用

    断言就比较简单了，同时也很有用，在大佬的代码中很常见。
    
    cpp异常(cpp_exception)
        一、异常的语法
            1）捕获全部的异常
                try
                {
                    // 可能抛出异常的代码。
                    // throw 异常对象;
                }
                // ...表示捕获所有未被具体匹配的异常
                catch (...)
                {
                    // 不管什么异常，都在这里统一处理。
                }
            2）捕获指定的异常
                try
                {
                    // 可能抛出异常的代码。
                    // throw 异常对象;
                }
                catch (exception1 e)
                {
                    // 发生exception1异常时的处理代码。
                }
                catch (exception2 e)
                {
                    // 发生exception2异常时的处理代码。
                }
            在try语句块中，如果没有发生异常，执行完try语句块中的代码后，将继续执行try语句块之后的代码；如果发生了异常，用throw抛出异常对象，异常对象的类型决定了应该匹配到哪个catch语句块，如果没有匹配到catch语句块，程序将调用abort()函数中止。
            如果try语句块中用throw抛出异常对象，并且匹配到了catch语句块，执行完catch语句块中的代码后，将继续执行catch语句块之后的代码，不会回到try语句块中。
            如果程序中的异常没有被捕获，程序将异常中止。
        栈解旋
            异常被抛出后，从进入try语句块开始，到异常被抛出之前，这期间在栈上构造的所有对象，都会被自动析构。析构的顺序与构造的顺序相反。这一过程称为栈的解旋。
            也就是在执行throw前，在try执行期间构造的所有对象被自动析构后，才会进入catch匹配。
            在堆上构造的对象肿么办？
        异常规范
            C++98标准提出了异常规范，目的是为了让使用者知道函数可能会引发哪些异常。
                void func1() throw(A, B, C);     // 表示该函数可能会抛出A、B、C类型的异常。
                void func2() throw();           // 表示该函数不会抛出异常。
                void func3();                  // 该函数不符合C++98的异常规范。
            C++11标准弃用了异常规范，使用新增的关键字noexcept指出函数不会引发异常。
                void func4() noexcept;         // 该函数不会抛出异常。
            在实际开发中，大部分程序员懒得在函数后面加noexcept，弃用异常已是共识，没必要多此一举。
            关键字noexcept也可以用作运算符，判断表达试（操作数）是否可能引发异常；如果表达式可能引发异常，则返回false，否则返回true。
        C++标准库异常
        重点关注的异常
            1）std::bad_alloc
                如果内存不足，调用new会产生异常，导致程序中止；如果在new关键字后面加(std::nothrow)选项，则返回nullptr，不会产生异常。
            2）std::bad_cast
                dynamic_cast可以用于引用，但是，C++没有与空指针对应的引用值，如果转换请求不正确，会出现std::bad_cast异常。
            3）std::bad_typeid
                假设有表达式typeid(*ptr)，当ptr是空指针时，如果ptr是多态的类型，将引发std::bad_typeid异常。
        逻辑错误异常
            程序的逻辑错误产生的异常std::logic_error，通过合理的编程可以避免。
            1）std::out_of_range
                Defines a type of object to be thrown as exception. It reports errors that are consequence of attempt to access elements out of defined range.
                It may be thrown by the member functions of std::bitset and std::basic_string, by std::stoi and std::stod families of functions, and by the bounds-checked member access functions (e.g. std::vector::at and std::map::at).
            2）std::length_error
                Defines a type of object to be thrown as exception. It reports errors that result from attempts to exceed implementation defined length limits for some object.
                This exception is thrown by member functions of std::basic_string and std::vector::reserve.
            3）std::domain_error
                Defines a type of object to be thrown as exception. It may be used by the implementation to report domain errors, that is, situations where the inputs are outside of the domain on which an operation is defined.
                The standard library components do not throw this exception (mathematical functions report domain errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::domain_error if boost::math::policies::throw_on_error is enabled (the default setting).
            4）std::invalid_argument
                Defines a type of object to be thrown as exception. It reports errors that arise because an argument value has not been accepted.
                This exception is thrown by std::bitset::bitset, and the std::stoi and std::stof families of functions.
        其它异常
            1）std::range_error
                Defines a type of object to be thrown as exception. It can be used to report range errors (that is, situations where a result of a computation cannot be represented by the destination type).
                The only standard library components that throw this exception are std::wstring_convert::from_bytes and std::wstring_convert::to_bytes.
                The mathematical functions in the standard library components do not throw this exception (mathematical functions report range errors as specified in math_errhandling).
            2）std::overflow_error
                Defines a type of object to be thrown as exception. It can be used to report arithmetic overflow errors (that is, situations where a result of a computation is too large for the destination type)
                The only standard library components that throw this exception are std::bitset::to_ulong and std::bitset::to_ullong.
                The mathematical functions of the standard library components do not throw this exception (mathematical functions report overflow errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::overflow_error if boost::math::policies::throw_on_error is enabled (the default setting).
            3）std::underflow_error
                Defines a type of object to be thrown as exception. It may be used to report arithmetic underflow errors (that is, situations where the result of a computation is a subnormal floating-point value)
                The standard library components do not throw this exception (mathematical functions report underflow errors as specified in math_errhandling). Third-party libraries, however, use this. For example, boost.math throws std::underflow_error if boost::math::policies::throw_on_error is enabled (the default setting
            4）ios_base::failure
                这个异常，程序员不主动找它就没事。
            5）std::bad_exception
                This is a special type of exception specifically designed to be listed in the dynamic-exception-specifier of a function (i.e., in its throw specifier).
                If a function with bad_exception listed in its dynamic-exception-specifier throws an exception not listed in it and unexpected rethrows it (or throws any other exception also not in the dynamic-exception-specifier), a bad_exception is automatically thrown.


    cpp断言(cpp_assertion)
        断言
            断言（assertion）是一种常用的编程手段，用于排除程序中不应该出现的逻辑错误。
            使用断言需要包含头文件<cassert>或<assert.h>，头文件中提供了带参数的宏assert，用于程序在运行时进行断言。
            语法：assert(表达式);
            断言就是判断(表达式)的值，如果为0（false），程序将调用abort()函数中止，如果为非0（true），程序继续执行。
            注意断言失败不是异常，不能捕获。
            断言可以提高程序的可读性，帮助程序员定位违反了某些前提条件的错误。
            注意：
                断言用于处理程序中不应该发生的错误，而非逻辑上可能会发生的错误。
                不要把需要执行的代码放到断言的表达式中。
                断言的代码一般放在函数/成员函数的第一行，表达式多为函数的形参。
        C++11静态断言
            assert宏是运行时断言，在程序运行的时候才能起作用。
            C++11新增了静态断言static_assert，用于在编译时检查源代码。
            使用静态断言不需要包含头文件。
            语法：static_assert(常量表达式,提示信息);
            注意：static_assert的第一个参数是常量表达式。而assert的表达式既可以是常量，也可以是变量。
        
        










贰叁.Cpp11新标准(023Cpp11NewStandard)

    cpp11标准2011年发布的，十四年了，现在各种平台和编译器都支持，今天来看，已经不能算是新标准了，只是cpp11标准是比较具有跨越性的革新，给开发者带来很多便利。
    cpp的标准的革新性更新的最具代表版本有
        cpp11，cpp17，cpp98(初代),cpp20
    c的标准的革新性更新的最具代表版本有
        c99，c89/90(初代)，c11

    cpp的新标准(cpp_new_standard)
        long long 类型
            基本类型讲到过
        char16_t 和 char32_t 类型
            很少用
        原始字面量
            详见45章节
        统一的初始化（列表）
            Girl g1(3, "西施");    // C++98的风格。
            Girl g2={5, "冰冰"};  // C++11的风格。
            Girl g3{8, "幂幂"};    // C++11的风格。
        自动推导类型 auto
            详见140章节
        decltype 关键字
            详见146章节
        函数后置返回类型
            详见146章节
        模板的别名
            详见220章节（本章节）
        空指针 nullptr
            详见220章节（本章节）
        智能指针
            详见193/196章节
        异常规范方面的修改
            详见209章节
        强类型枚举（枚举类）
            详见220章节（本章节）
            很少用
        explicit 关键字
            详见121章节
        类内成员初始化
            详见220章节（本章节）
        基于范围的 for 循环
            详见184章节
        新的 STL 容器
            详见STL容器(181-191)章节
        新的 STL 方法（成员函数）
            详见STL容器(181-191)章节
            详见220章节（本章节）
        摒弃 export
            C++98新增了export关键字，C++11不再使用，但仍保留它作为关键字，供以后使用。
            很少用
        嵌套模板的尖括号
            详见220章节（本章节）
        final 关键字
            详见220章节（本章节）
        override 关键字
            详见220章节（本章节）
        数值类型和字符串之间的转换
            详见220章节（本章节）
        静态断言 static_assert
            详见210章节（本章节）
        常量表达式 constexpr 关键字
            详见220章节（本章节）
        默认函数控制 =default 与 =delete
            详见220章节（本章节）
        
    委托构造和继承构造(delegate_construction_and_inheritance_construction)
        C++11标准新增了委托构造和继承构造两种方法，用于简化代码。
        委托构造
            在实际的开发中，为了满足不同的需求，一个类可能会重载多个构造函数。多个构造函数之间可能会有重复的代码。例如变量初始化，如果在每个构造函数中都写一遍，这样代码会显得臃肿。
            委托构造就是在一个构造函数的初始化列表中调用另一个构造函数。
            注意：
                不要生成环状的构造过程。
                一旦使用委托构造，就不能在初始化列表中初始化其它的成员变量。
        继承构造
            在C++11之前，派生类如果要使用基类的构造函数，可以在派生类构造函数的初始化列表中指定。在《126、如何构造基类》中有详细介绍。
            C++11推出了继承构造（Inheriting Constructor），在派生类中使用using来声明继承基类的构造函数。
            
    Lambda函数(lambda_func)
        lambda函数是C++11标准新增的语法糖，也称为lambda表达式或匿名函数。
        lambda函数的特点是：距离近、简洁、高效和功能强大。
        示例：[](const int& no) -> void { cout << "亲爱的" << no << "号：我是一只傻傻鸟。\n"; };
        语法：详见222章节
        
        参数列表
            参数列表是可选的，类似普通函数的参数列表，如果没有参数列表，()可以省略不写。
            与普通函数的不同：
                lambda函数不能有默认参数。
                所有参数必须有参数名。
                不支持可变参数。
        返回类型
            用后置的方法书写返回类型，类似于普通函数的返回类型，如果不写返回类型，编译器会根据函数体中的代码推断出来。
            如果有返回类型，建议显式的指定，自动推断可能与预期不一致。
        函数体
            类似于普通函数的函数体。
        捕获列表
            通过捕获列表，lambda函数可以访问父作用域中的非静态局部变量（静态局部变量可以直接访问，不能访问全局变量）。
            捕获列表书写在[]中，与函数参数的传递类似，捕获方式可以是值和引用。
            以下列出了不同的捕获列表的方式。
                详见222章节
            1）值捕获
                与传递参数类似，采用值捕获的前提是变量可以拷贝。
                与传递参数不同，变量的值是在lambda函数创建时拷贝，而不是调用时拷贝。
                例如：
                    size_t v1 = 42;
                    auto f = [ v1 ]  { return v1; };	// 使用了值捕获，将v1拷贝到名为f的可调用对象。
                    v1 = 0;
                    auto j = f();    // j为42，f保存了我们创建它是v1的拷贝。
                由于被捕获的值是在lambda函数创建时拷贝，因此在随后对其修改不会影响到lambda内部的值。
                默认情况下，如果以传值方式捕获变量，则在lambda函数中不能修改变量的值。
            2）引用捕获
                和函数引用参数一样，引用变量的值在lambda函数体中改变时，将影响被引用的对象。
                    size_t v1 = 42;
                    auto f = [ &v1 ]  { return v1; };	 // 引用捕获，将v1拷贝到名为f的可调用对象。
                    v1 = 0;
                    auto j = f();	   // j为0。
                如果采用引用方式捕获变量，就必须保证被引用的对象在lambda执行的时候是存在的。
            3）隐式捕获
                除了显式列出我们希望使用的父作域的变量之外，还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。
                隐式捕获有两种方式，分别是[=]和[&]。[=]表示以值捕获的方式捕获外部变量，[&]表示以引用捕获的方式捕获外部变量。
                    int a = 123;
                    auto f = [ = ]  { cout << a << endl; };		//值捕获
                    f(); 	// 输出：123
                    auto f1 = [ & ] { cout << a++ << endl; }; 		//引用捕获
                    f1();	//输出：123（采用了后++）
                    cout << a << endl; 		//输出 124
            4）混合方式捕获
                lambda函数还支持混合方式捕获，即同时使用显式捕获和隐式捕获。
                混合捕获时，捕获列表中的第一个元素必须是 = 或 &，此符号指定了默认捕获的方式是值捕获或引用捕获。
                需要注意的是：显式捕获的变量必须使用和默认捕获不同的方式捕获。例如：
                    int i = 10;
                    int  j = 20;
                    auto f1 = [ =, &i] () { return j + i; };		// 正确，默认值捕获，显式是引用捕获
                    auto f2 = [ =, i] () { return i + j; };		// 编译出错，默认值捕获，显式值捕获，冲突了
                    auto f3 = [ &, &i] () { return i +j; };		// 编译出错，默认引用捕获，显式引用捕获，冲突了
            5）修改值捕获变量的值
                在lambda函数中，如果以传值方式捕获变量，则函数体中不能修改该变量，否则会引发编译错误。
                在lambda函数中，如果希望修改值捕获变量的值，可以加mutable选项，但是，在lambda函数的外部，变量的值不会被修改。
                    int a = 123;
                    auto f = [a]()mutable { cout << ++a << endl; }; // 不会报错
                    cout << a << endl; 	// 输出：123
                    f(); 					// 输出：124
                    cout << a << endl; 	// 输出：123
            6）异常说明
                lambda可以抛出异常，用throw(…)指示异常的类型，用noexcept指示不抛出任何异常。
        lambda函数的本质
            当我们编写了一个lambda函数之后，编译器将它翻译成一个类，该类中有一个重载了()的函数。
            1）采用值捕获
                采用值捕获时，lambda函数生成的类用捕获变量的值初始化自己的成员变量。
                例如：
                    int a =10;
                    int b = 20;
                    auto addfun = [=] (const int c ) -> int { return a+c; };
                    int c = addfun(b);    
                    cout << c << endl;
                等同于：
                    class Myclass
                    {
                        int m_a;		// 该成员变量对应通过值捕获的变量。
                        public:
                        Myclass( int a ) : m_a(a){};	// 该形参对应捕获的变量。
                        // 重载了()运算符的函数，返回类型、形参和函数体都与lambda函数一致。
                        int operator()(const int c) const
                        {
                            return a + c;
                        }
                    };
                默认情况下，由lambda函数生成的类是const成员函数，所以变量的值不能修改。如果加上mutable，相当于去掉const。这样上面的限制就能讲通了。
            2）采用引用捕获
                如果lambda函数采用引用捕获的方式，编译器直接引用就行了。
                唯一需要注意的是，lambda函数执行时，程序必须保证引用的对象有效。

    右值引用(r_value_references)
        
        TODO
        TODO
        TODO
        TODO
        TODO
        TODO
        
        左值、右值
            在C++中，所有的值不是左值，就是右值。左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束后就不再存在的临时对象。有名字的对象都是左值，右值没有名字。
            还有一个可以区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值。
            C++11扩展了右值的概念，将右值分为了纯右值和将亡值。
            纯右值：
                a）非引用返回的临时变量；
                b）运算表达式产生的结果；
                c）字面常量（C风格字符串除外，它是地址）。
            将亡值：
                与右值引用相关的表达式，例如：将要被移动的对象、T&&函数返回的值、std::move()的返回值、转换成T&&的类型的转换函数的返回值。
            不懂纯右值和将亡值的区别其实没关系，统一看作右值即可，不影响使用。
        左值引用、右值引用
            C++98中的引用很常见，就是给变量取个别名，在C++11中，因为增加了右值引用(rvalue reference)的概念，所以C++98中的引用都称为了左值引用(lvalue reference)。
            右值引用就是给右值取个名字。
            语法：数据类型&& 变量名=右值;
        引入右值引用的主要目的是实现移动语义。
            左值引用只能绑定（关联、指向）左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。
            但是，常量左值引用却是个奇葩，它可以算是一个万能的引用类型，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长，缺点是，只能读不能改。
                int a = 1;        
                const int& ra = a;   // a是非常量左值。
                
                const int b = 1;  
                const int& rb = b;  // b是常量左值。
                
                const int& rc = 1;   // 1是右值。
            总结一下，其中T是一个具体类型：
                1）左值引用， 使用 T&, 只能绑定左值。
                2）右值引用， 使用 T&&， 只能绑定右值。
                3）已命名的右值引用是左值。
                4）常量左值，使用 const T&, 既可以绑定左值又可以绑定右值。

    移动语义(move_semantics)
        












贰肆.Cpp11线程(024Cpp11Thread)
贰伍.可调用对象的绑定器和包装器(025BinderAndPackaging)









零、壹、贰、叁、肆、伍、陆、柒、捌、玖、拾;
